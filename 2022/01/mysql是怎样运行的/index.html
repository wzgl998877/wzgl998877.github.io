<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>
        Mysql是怎样运行的 - 码农的学习笔记
      </title>
        <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    
    <meta name="theme-color" content="#000000" />
    
    <meta http-equiv="window-target" content="_top" />
    
    
    <meta name="description" content="[TOC] 本篇文章是(Mysql是怎样运行的)阅读笔记，这本书网上很多人的评价都很高，看了下书也不是很厚，所以读读。 MySQL的架构 mysql 工作的整体流程" />
    <meta name="generator" content="Hugo 0.91.2 with theme pure" />
    <title>Mysql是怎样运行的 - 码农的学习笔记</title>
    
    
    <link rel="stylesheet" href="https://wzgl998877.github.io/css/style.min.a85959a41e7abcc0db1f81f44bd264649303417f91b536e87dcde644340fea6d.css">
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.15.10/styles/github.min.css" async>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css" async>
    <meta property="og:title" content="Mysql是怎样运行的" />
<meta property="og:description" content="[TOC] 本篇文章是(Mysql是怎样运行的)阅读笔记，这本书网上很多人的评价都很高，看了下书也不是很厚，所以读读。 MySQL的架构 mysql 工作的整体流程" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wzgl998877.github.io/2022/01/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-12T11:24:40+08:00" />
<meta property="article:modified_time" content="2022-01-12T11:24:40+08:00" />

<meta itemprop="name" content="Mysql是怎样运行的">
<meta itemprop="description" content="[TOC] 本篇文章是(Mysql是怎样运行的)阅读笔记，这本书网上很多人的评价都很高，看了下书也不是很厚，所以读读。 MySQL的架构 mysql 工作的整体流程"><meta itemprop="datePublished" content="2022-01-12T11:24:40+08:00" />
<meta itemprop="dateModified" content="2022-01-12T11:24:40+08:00" />
<meta itemprop="wordCount" content="83528">
<meta itemprop="keywords" content="mysql," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mysql是怎样运行的"/>
<meta name="twitter:description" content="[TOC] 本篇文章是(Mysql是怎样运行的)阅读笔记，这本书网上很多人的评价都很高，看了下书也不是很厚，所以读读。 MySQL的架构 mysql 工作的整体流程"/>

    <!--[if lte IE 9]>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
      <![endif]-->

    <!--[if lt IE 9]>
        <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
      <![endif]-->
  </head>

  
  

  <body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader">
    <div class="slimContent">
      <div class="navbar-header">
        <div class="profile-block text-center">
          <a id="avatar" href="https://github.com/wzgl998877/" target="_blank">
            <img class="img-circle img-rotate" src="https://wzgl998877.github.io/avatar.png" width="200" height="200">
          </a>
          <h2 id="name" class="hidden-xs hidden-sm">microzheng</h2>
          <h3 id="title" class="hidden-xs hidden-sm hidden-md">努力会说谎，但努力不会白费</h3>
          <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i>Shenzhen China</small>
        </div><div class="search" id="search-form-wrap">
    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i
                        class="icon icon-search"></i></button>
            </span>
        </div>
        <div class="ins-search">
            <div class="ins-search-mask"></div>
            <div class="ins-search-container">
                <div class="ins-input-wrapper">
                    <input type="text" class="ins-search-input" placeholder="想要查找什么..."
                        x-webkit-speech />
                    <button type="button" class="close ins-close ins-selectable" data-dismiss="modal"
                        aria-label="Close"><span aria-hidden="true">×</span></button>
                </div>
                <div class="ins-section-wrapper">
                    <div class="ins-section-container"></div>
                </div>
            </div>
        </div>
    </form>
</div>
        <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
      </div>
      <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
        <ul class="nav navbar-nav main-nav">
            <li class="menu-item menu-item-home">
                <a href="/">
                    <i class="icon icon-home-fill"></i>
                  <span class="menu-title">主页</span>
                </a>
            </li>
            <li class="menu-item menu-item-archives">
                <a href="/posts/">
                    <i class="icon icon-archives-fill"></i>
                  <span class="menu-title">归档</span>
                </a>
            </li>
            <li class="menu-item menu-item-categories">
                <a href="/categories/">
                    <i class="icon icon-folder"></i>
                  <span class="menu-title">分类</span>
                </a>
            </li>
            <li class="menu-item menu-item-tags">
                <a href="/tags/">
                    <i class="icon icon-tags"></i>
                  <span class="menu-title">标签</span>
                </a>
            </li>
        </ul>
      </nav>
    </div>
  </header>

<aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content"><p>enjoy~</p>
            </div>
        </div>
    </div>
</div>

      <div class="widget">
    <h3 class="widget-title"> 分类</h3>
    <div class="widget-body">
        <ul class="category-list">
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/git/" class="category-list-link">git</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/java/" class="category-list-link">java</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/spring/" class="category-list-link">spring</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="category-list-link">中间件</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/" class="category-list-link">云原生</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" class="category-list-link">常用框架</a><span class="category-list-count">4</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-list-link">数据库</a><span class="category-list-count">4</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/" class="category-list-link">日常总结</a><span class="category-list-count">3</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E7%AE%97%E6%B3%95/" class="category-list-link">算法</a><span class="category-list-count">2</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="category-list-link">系统设计</a><span class="category-list-count">1</span></li>
            <li class="category-list-item"><a href="https://wzgl998877.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="category-list-link">网络编程</a><span class="category-list-count">3</span></li>
        </ul>
    </div>
</div>
      <div class="widget">
    <h3 class="widget-title"> 标签</h3>
    <div class="widget-body">
        <ul class="tag-list">
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/http/" class="tag-list-link">http</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/java%E5%9F%BA%E7%A1%80/" class="tag-list-link">java基础</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/java%E5%B9%B6%E5%8F%91/" class="tag-list-link">java并发</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/jvm/" class="tag-list-link">jvm</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/leetcode/" class="tag-list-link">leetcode</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/mybatis/" class="tag-list-link">mybatis</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/mysql/" class="tag-list-link">mysql</a><span
                    class="tag-list-count">3</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/netty/" class="tag-list-link">netty</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/redis/" class="tag-list-link">redis</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/rpc/" class="tag-list-link">rpc</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/spring/" class="tag-list-link">spring</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/websocket/" class="tag-list-link">websocket</a><span
                    class="tag-list-count">1</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="tag-list-link">消息队列</a><span
                    class="tag-list-count">2</span></li>
            
            
            <li class="tag-list-item"><a href="https://wzgl998877.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="tag-list-link">设计模式</a><span
                    class="tag-list-count">1</span></li>
            
        </ul>

    </div>
</div>
      
<div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
        <ul class="recent-post-list list-unstyled no-thumbnail">
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://wzgl998877.github.io/2024/09/%E9%AB%98%E6%80%A7%E8%83%BDmysql/" class="title">高性能Mysql</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2024-09-11 20:03:12 &#43;0800 CST" itemprop="datePublished">2024-09-11</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://wzgl998877.github.io/2022/11/springcloud/" class="title">SpringCloud</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-11-07 19:15:43 &#43;0800 CST" itemprop="datePublished">2022-11-07</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://wzgl998877.github.io/2022/09/docker%E5%92%8Ck8s/" class="title">Docker和k8s</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-09-09 10:26:21 &#43;0800 CST" itemprop="datePublished">2022-09-09</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://wzgl998877.github.io/2022/05/redis%E6%80%BB%E7%BB%93/" class="title">Redis学习</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-05-06 15:21:49 &#43;0800 CST" itemprop="datePublished">2022-05-06</time>
                    </p>
                </div>
            </li>
            <li>
                <div class="item-inner">
                    <p class="item-title">
                        <a href="https://wzgl998877.github.io/2022/03/git%E7%9B%B8%E5%85%B3/" class="title">git相关</a>
                    </p>
                    <p class="item-date">
                        <time datetime="2022-03-02 20:03:24 &#43;0800 CST" itemprop="datePublished">2022-03-02</time>
                    </p>
                </div>
            </li>
        </ul>
    </div>
</div>
  </div>
</aside>

    
    
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <h4 class="toc-title">文章目录</h4>
    <nav id="toc" class="js-toc toc">

    </nav>
  </div>
</aside>
<main class="main" role="main"><div class="content">
  <article id="-" class="article article-type-" itemscope
    itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      <h1 itemprop="name">
  <a
    class="article-title"
    href="/2022/01/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/"
    >Mysql是怎样运行的</a
  >
</h1>

      <div class="article-meta">
        
<span class="article-date">
  <i class="icon icon-calendar-check"></i>&nbsp;
<a href="https://wzgl998877.github.io/2022/01/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/" class="article-date">
  <time datetime="2022-01-12 11:24:40 &#43;0800 CST" itemprop="datePublished">2022-01-12</time>
</a>
</span>
<span class="article-category">
  <i class="icon icon-folder"></i>&nbsp;
  <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"> 数据库 </a>
</span>  
  <span class="article-tag">
    <i class="icon icon-tags"></i>&nbsp;
    <a class="article-tag-link" href="/tags/mysql/"> mysql </a>
  </span>

		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 83528字</span>
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 167分 </span>
      </div>
    </div>
    <div class="article-entry marked-body js-toc-content" itemprop="articleBody">
      <p>[TOC]</p>
<p>本篇文章是(Mysql是怎样运行的)阅读笔记，这本书网上很多人的评价都很高，看了下书也不是很厚，所以读读。</p>
<h2 id="mysql的架构">MySQL的架构</h2>
<p>mysql 工作的整体流程为，客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。如图：</p>
<p><img src="./image-20220111152436653.png" alt="image-20220111152436653"></p>
<h3 id="连接管理">连接管理</h3>
<p>​	客户端进程可以采用我们上边介绍的TCP/IP 、命名管道或共享内存、Unix域套接字这几种方式之一来与服务
器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个
客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而
是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频
繁创建和销毁线程的效果，从而节省开销。
​	<strong>当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来的请求， MySQL 服务器接收到的请求只是一个文本消息</strong>，该文本消息还要经过各种处理，才能转化为mysql能识别的语句。</p>
<h3 id="解析与优化">解析与优化</h3>
<p>​	 MySQL 服务器获得了文本形式的请求后，接着 还要经过九九八十一难的处理，其中的几个比较重要的部分分别是查询缓存、语法解析和查询优化。</p>
<h4 id="查询缓存">查询缓存</h4>
<p>​	<strong>MySQL  服务器程序处理查询请求时，会把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了</strong>，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。
​	当然， MySQL 服务器并没有人聪明，如果两个查询请求在任何字符上的不同（例如：空格、注释、大小写），都会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如
mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数NOW ，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！
不过既然是缓存，那就有它缓存失效的时候。</p>
<p>​	<strong>MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改</strong>，如对该表使用了INSERT 、 UPDATE 、DELETE 、TRUNCATE TABLE 、ALTER TABLE 、DROP TABLE 或 DROP DATABASE 语句，<strong>那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除</strong>！</p>
<blockquote>
<p>虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如<strong>每次都要去查</strong>
<strong>询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域</strong>。从MySQL 5.7.20
开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p>
</blockquote>
<h4 id="语法解析">语法解析</h4>
<p>​	如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以MySQL 服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到MySQL 服务器内部使用的一些数据结构上来。</p>
<h4 id="查询优化">查询优化</h4>
<p>​	语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，<strong>因为我们写的MySQL 语句执行起来效率可能并不是很高， MySQL 的优化程序会对我们的语句做一些优化</strong>，如外连接转换为内连接、表达式简化、子查询转为连接等。<strong>优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用EXPLAIN 语句来查看某个语句的执行计划</strong></p>
<h3 id="存储引擎">存储引擎</h3>
<p>​	截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表， MySQL 服务器把数据的存储和提取操作都封装到了一个叫存储引擎的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概
念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责
的事情。为了实现不同的功能， MySQL 提供了各式各样的存储引擎，不同存储引擎管理的表具体的存储结构
可能不同，采用的存取算法也可能不同。</p>
<p>​	为了管理方便，人们把连接管理、查询缓存、语法解析、查询优化这些并不涉及真实数据存储的功能划分
为MySQL server 的功能，把真实存取数据的功能划分为存储引擎的功能。<strong>各种不同的存储引擎向上边的MySQL</strong>
<strong>server 层提供统一的调用接口（也就是存储引擎API）</strong>，包含了几十个底层函数，像&quot;读取索引第一条内容&quot;、&ldquo;读
取索引下一条内容&rdquo;、&ldquo;插入记录&quot;等等。</p>
<p>​	常用的存储引擎有：ARCHIVE、BLACKHOLE、InnoDB、MyISAM等，最常用的就是InnoDB 和MyISAM，<strong>其中InnoDB 是MySQL 默认的存储引擎</strong>。</p>
<h2 id="深入研究innodb">深入研究InnoDB</h2>
<p>​	<strong>InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的</strong>。<strong>而真正处</strong>
<strong>理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还</strong>
<strong>需要把内存中的内容刷新到磁盘上</strong>。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我
们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，
<strong>InnoDB 采取的方式是：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小</strong>
<strong>一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB</strong>
<strong>内容刷新到磁盘中</strong></p>
<h3 id="innodb行格式">InnoDB行格式</h3>
<p>​	我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为<strong>行格式或者记录格式</strong>。
设计InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的行格式，分别是Compact 、Redundant 、
Dynamic 和Compressed 行格式。</p>
<h4 id="compact">Compact</h4>
<p><img src="./image-20220111160208062.png" alt="image-20220111160208062"></p>
<p>​	从图中可以看出来，一条完整的记录其实可以被分为记录的<strong>额外信息</strong>和记录的<strong>真实数据</strong>两大部分，下边我
们详细看一下这两部分的组成。</p>
<h5 id="记录的额外信息">记录的额外信息</h5>
<p>​	这部分信息是服务器为了描述这条记录而不得不额外添加的一些信息，这些额外信息分为3类，分别是<strong>变长字段</strong>
<strong>长度列表、NULL值列表和记录头信息</strong>，我们分别看一下。</p>
<p><strong>变长字段长度列表</strong></p>
<p>​	<strong>MySQL 支持一些变长的数据类型，比如VARCHAR(M) 、VARBINARY(M) 、各种TEXT 类型，各种BLOB 类型</strong>，我们也可以把拥有这些数据类型的列称为变长字段，<strong>变长字段中存储多少字节的数据是不固定的</strong>，所以我
们在存储真实数据的时候需要顺便把<strong>这些数据占用的字节数也存起来</strong>，这样才不至于把MySQL 服务器搞懵，所以
这些变长字段占用的存储空间分为两部分：</p>
<ol>
<li>真正的数据内容</li>
<li>占用的字节数</li>
</ol>
<p>在Compact 行格式中，<strong>把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长</strong>
<strong>字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放</strong>！</p>
<p>我们拿record_format_demo 表中的第一条记录来举个例子。因为record_format_demo 表的c1 、c2 、c4 列
<strong>都是VARCHAR(10) 类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处</strong>，因为
record_format_demo 表中的各个列都使用的是ascii 字符集，所以每个字符只需要1个字节来进行编码，来看
一下第一条记录各变长字段内容的长度：</p>
<table>
<thead>
<tr>
<th style="text-align:center">存储内容</th>
<th style="text-align:center">内容长度（十进制表示）</th>
<th style="text-align:center">列名</th>
<th style="text-align:center">内容长度（十六进制表示）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lsquo;aaaa&rsquo;</td>
<td style="text-align:center">4</td>
<td style="text-align:center">c1</td>
<td style="text-align:center">0x04</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;bbb&rsquo;</td>
<td style="text-align:center">3</td>
<td style="text-align:center">c2</td>
<td style="text-align:center">0x03</td>
</tr>
<tr>
<td style="text-align:center">&rsquo;d'</td>
<td style="text-align:center">1</td>
<td style="text-align:center">c4</td>
<td style="text-align:center">0x01</td>
</tr>
</tbody>
</table>
<p>又因为这些长度值需要按照列的逆序存放，所以最后变长字段长度列表的字节串用十六进制表示的效果就是
（各个字节之间实际上没有空格，用空格隔开只是方便理解）：
01 03 04
把这个字节串组成的变长字段长度列表填入上边的示意图中的效果就是：</p>
<p><img src="./image-20220111163920752.png" alt="image-20220111163920752"></p>
<p>由于第一行记录中c1 、c2 、c4 列中的字符串都比较短，<strong>也就是说内容占用的字节数比较小，用1个字节就可</strong>
<strong>以表示</strong>，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来
表示真实数据占用的字节数， InnoDB 有它的一套规则，我们首先声明一下W 、M 和L 的意思：</p>
<ol>
<li>假设某个字符集中表示一个字符最多需要使用的字节数为W ，也就是使用SHOW CHARSET 语句的结果中的
Maxlen 列，比方说utf8 字符集中的W 就是3 ， gbk 字符集中的W 就是2 ， ascii 字符集中的W 就是1 。</li>
<li>对于变长类型VARCHAR(M) 来说，这种类型表示能存储最多M 个字符（注意是字符不是字节），所以这个类
型能表示的字符串最多占用的字节数就是M×W 。</li>
<li>假设它实际存储的字符串占用的字节数是L 。</li>
</ol>
<blockquote>
<p>所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：
如果M×W &lt;= 255 ，那么使用1个字节来表示真正字符串占用的字节数，为什么呢？很简单因为一个字节由8位二进制构成而8位二进制最多也只能表示256这个数，（<strong>但还有一位是标志位所以就是255</strong>）。</p>
<p>​	如果M×W &gt; 255 ，则分为两种情况：
​	如果L &lt;= 127 ，则用1个字节来表示真正字符串占用的字节数。
​	如果L &gt; 127 ，则用2个字节来表示真正字符串占用的字节数。
InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节
数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？
设计InnoDB的大叔使用该<strong>字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那</strong>
**该字节就是一个单独的字段长度（**使用一个字节表示不大于127的二进制的第一个位都为0），
<strong>如果该字节的第一个位为1，那该字节就是半个字段长度</strong>。
对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个
页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变
长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。</p>
</blockquote>
<p>总结一下就是说：<strong>如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ）</strong>
<strong>超过127字节，则使用2个字节，否则使用1个字节</strong>。</p>
<p><strong>NULL值列表</strong></p>
<p>​	我们知道表中的某些列可能存储NULL 值，如果把这些NULL 值都放到记录的真实数据中存储会很占地方，所
以Compact 行格式把这些值为NULL 的列统一管理起来，存储到NULL 值列表中，它的处理过程是这样的</p>
<ol>
<li>首先统计表中允许存储NULL 的列有哪些。
我们前边说过，主键列、被NOT NULL 修饰的列都是不可以存储NULL 值的，所以在统计的时候不会把这些列
算进去。比方说表record_format_demo 的3个列c1 、c3 、c4 都是允许存储NULL 值的，而c2 列是被
NOT NULL 修饰，不允许存储NULL 值。</li>
<li><strong>如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了</strong>，否则将每个允许存储NULL 的列对应一个
二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
<strong>二进制位的值为1 时，代表该列的值为NULL 。</strong>
<strong>二进制位的值为0 时，代表该列的值不为NULL 。</strong>
再一次强调，二进制位按照列的顺序逆序排列，所以第一个列c1 和最后一个二进制位对应。：</li>
</ol>
<p><img src="./image-20220111172042816.png" alt="image-20220111172042816"></p>
<ol start="3">
<li><strong>MySQL 规定NULL值列表必须用整数个字节的位表示</strong>，如果使用的二进制位个数不是整数个字节，则在字节
的高位补0 。表record_format_demo 只有3个值允许为NULL 的列，对应3个二进制位，不足一个字节，所以在字节的高位补0 ，效果就是这样：</li>
</ol>
<p><img src="./image-20220111172201192.png" alt="image-20220111172201192"></p>
<p>知道了规则后，再看看null值列表应该怎么存储，因为只有c1 、c3 、c4 都是允许存储NULL 值的所以只需要一个字节。</p>
<p>对于第一条记录来说， c1 、c3 、c4 这3个列的值都不为NULL ，所以它们对应的二进制位都是0 ，用十六进制表示就是0x00 
对于第二条记录来说， c1 、c3 、c4 这3个列中c3 和c4 的值都为NULL ，用十六进制表示就是： 0x06 。所以添加后为</p>
<p><img src="./image-20220111172546954.png" alt="image-20220111172546954"></p>
<p><strong>记录头信息</strong></p>
<p>​	除了变长字段长度列表、NULL值列表之外，还有一个用于描述记录的记录头信息，它是由固定的5 个字节组
成。5 个字节也就是40 个二进制位，不同的位代表不同的意思</p>
<h5 id="记录的真实数据">记录的真实数据</h5>
<p>​	对于record_format_demo 表来说， 记录的真实数据除了c1 、c2 、c3 、c4 这几个我们自己定义的列的数据
以外， MySQL 会为每个记录默认的添加一些列（也称为隐藏列），具体的列如下：
实际上这几个列的真正名称其实是：DB_ROW_ID （行ID唯一标识一条记录）、DB_TRX_ID（事务ID）、DB_ROLL_PTR（回滚指针）。
这里需要提一下InnoDB 表对主键的生成策略：优<strong>先使用用户自定义主键作为主键，如果用户没有定义主键，则</strong>
<strong>选取一个Unique 键作为主键，如果表中连Unique 键都没有定义的话，则InnoDB 会为表默认添加一个名为</strong>
<strong>row_id 的隐藏列作为主键</strong>。所以我们从上表中可以看出：InnoDB存储引擎会为每条记录都添加 transaction_id
和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）。
这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的。加上记录的真实数据的两个记录为：</p>
<p><img src="./image-20220111181502066.png" alt="image-20220111181502066"></p>
<p>看这个图的时候我们需要注意几点：</p>
<ol>
<li>表record_format_demo 使用的是ascii 字符集，所以0x61616161 就表示字符串&rsquo;aaaa' ， 0x626262 就表
示字符串&rsquo;bbb' ，以此类推。</li>
<li><strong>注意第1条记录中c3 列的值，它是CHAR(10) 类型的，它实际存储的字符串是： &lsquo;cc&rsquo; ，而ascii 字符集中</strong>
<strong>的字节表示是'0x6363' ，虽然表示这个字符串只占用了2个字节</strong>，但整个c3 列仍然占用了10个字节的空
间，<strong>除真实数据以外的8个字节的统统都用空格字符填充，空格字符在ascii 字符集的表示就是0x20</strong> 。</li>
<li>注意第2条记录中c3 和c4 列的值都为NULL ，它们被存储在了前边的NULL值列表处，在记录的真实数据处
就不再冗余存储，从而节省存储空间。</li>
</ol>
<p>对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，<strong>而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</strong></p>
<p>​	另外有一点还需要注意，变长字符集的CHAR(M) 类型的列要求至少占用M 个字节，而VARCHAR(M) 却没有这个要求。比方说对于使用u<strong>tf8 字符集的CHAR(10) 的列来说，该列存储的数据字节长度的范围是10～30个字节</strong>。即
使我们向该列中存储一个空字符串也会占用10 个字节，<strong>这是怕将来更新该列的值的字节长度大于原有值的字节</strong>
<strong>长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有</strong>
<strong>的记录空间成为所谓的碎片。</strong></p>
<h5 id="行溢出数据">行溢出数据</h5>
<p>​	我们知道对于<strong>VARCHAR(M) 类型的列最多可以占用65535 个字节</strong>。其中的M 代表该类型最多存储的字符数量，如果我们使用ascii 字符集的话，一个字符就代表一个字节。为什么最多是65535呢？很简单，因为前面讲过的</p>
<p><strong>如果该可变字段允许存储的最大字节数（ M×W ）超过255字节并且真实存储的字节数（ L ）</strong>
<strong>超过127字节，则使用2个字节，否则使用1个字节</strong>。<strong>也就是说一个可变字段允许存储的最大字节数的长度最多只能用2个字节存储，而两个字节能表示的最大长度就是256*256=65536然后需要减去一个标志位</strong>。</p>
<p>​	MySQL 对一条记录占用的最大存储空间是有限制的，除了BLOB 或者TEXT 类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535 个字节。所以MySQL 服务器建议我们把存储类型改为TEXT 或者BLOB 的类型。这个65535 个字节除了列本身的数据之外，还包括一些其他的数据（ storage overhead ），比如说我们为了存储一个VARCHAR(M) 类型的列，其实需要占用3部分存储空间：</p>
<ul>
<li>真实数据</li>
<li>真实数据占用字节的长度(<strong>变长字段长度列表最多为两个字节</strong>)</li>
<li>NULL 值标识，如果该列有NOT NULL 属性则可以没有这部分存储空间（<strong>NULL值列表，一个字节</strong>）</li>
</ul>
<blockquote>
<p>因此，如果该VARCHAR(M)类型的列没有NOT NULL 属性，那最多只能存储65532 个字节的数据（65535-2-1），而根据字符集的不同，最大能存储的字符数也不同，比如gbk 字符集表示一个字符最多需要2 个字
节，那在该字符集下， M 的最大取值就是32766 （也就是：65532/2），也就是说最多能存储32766 个字符；utf8 字符集表示一个字符最多需要3 个字节，那在该字符集下， M 的最大取值就是21844 ，就是说最多能存储21844 （也就是：65532/3）个字符。</p>
</blockquote>
<h5 id="记录中的数据太多产生的溢出">记录中的数据太多产生的溢出</h5>
<p>​	MySQL 中磁盘和内存交互的基本单位是页，也就是说MySQL 是以页为基本单位来管理存储空间的，我们的记录都会被分配到某个页中存储。<strong>而一个页的大小一般是16KB ，也就是16384 字节，而一个VARCHAR(M) 类</strong>
<strong>型的列就最多可以存储65532 个字节，这样就可能造成一个页存放不了一条记录</strong>的尴尬情况</p>
<p>​	对于Compact 和Reduntant 行格式来说，<strong>如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768 字节的那些页面也被称为溢出页</strong></p>
<p><img src="./image-20220112104651557.png" alt="image-20220112104651557"></p>
<blockquote>
<p>不只是 VARCHAR(M) 类型的列，其他的 TEXT、BLOB 类型的列在存储数据非常多的时候也会发生行溢出。</p>
</blockquote>
<p>总结：<strong>对于Compact 来说，所占用的额外信息最多为27 字节</strong>：</p>
<ul>
<li>
<p>2个字节用于存储真实数据的长度（最多）</p>
</li>
<li>
<p>1个字节用于存储列是否是NULL值（如果该列有NOT NULL 属性则可以没有这部分存储空间）</p>
</li>
<li>
<p>5个字节大小的头信息</p>
</li>
<li>
<p>6个字节的row_id 列（在没有自定义主键以及Unique键的情况下）</p>
</li>
<li>
<p>6个字节的transaction_id 列</p>
</li>
<li>
<p>7个字节的roll_pointer 列</p>
</li>
</ul>
<h4 id="dynamic和compressed行格式">Dynamic和Compressed行格式</h4>
<p>​	Dynamic 和Compressed 行格式 ，这俩行格式和Compact 行格式挺像，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：</p>
<p><img src="./image-20220112105546186.png" alt="image-20220112105546186"></p>
<p><strong>其中mysql5.6 默认使用 Compact，mysql 5.7 默认使用Dynamic</strong></p>
<h3 id="innodb数据页结构">InnoDB数据页结构</h3>
<p>​	<strong>页是InnoDB 管理存储空间的基本单位，一个页的大小一般是16KB</strong> 。InnoDB 为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放Insert Buffer信息的页，存放INODE 信息的页，存放undo 日志信息的页等。我们聚焦的是那些<strong>存放我们表中记录的那种类型的页，官方称这种存放记录的页为索引（ INDEX ）页</strong>。数据页代表的这块16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示：</p>
<p><img src="./image-20220112112222964.png" alt="image-20220112112222964"></p>
<h4 id="记录在页中的存储">记录在页中的存储</h4>
<p>​	在页的7个组成部分中，我们自己存储的记录会按照我们指定的<strong>行格式</strong>存储到<strong>User Records</strong> 部分。但是在一开
始生成页的时候，其实并没有User Records 这个部分，每当我们插入一条记录，都会从Free Space 部分，也就
是尚未使用的存储空间中申请一个记录大小的空间划分到User Records 部分，当Free Space 部分的空间全部
被User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新
的页了，这个过程的图示如下：</p>
<p><img src="./image-20220112112438399.png" alt="image-20220112112438399"></p>
<p>为了更好的管理在User Records 中的这些记录， InnoDB 可费了一番力气呢，在哪费力气了呢？不就是把记录按
照指定的行格式一条一条摆在User Records 部分么？其实这话还得从记录行格式的记录头信息中说起。</p>
<h5 id="记录头信息的秘密">记录头信息的秘密</h5>
<p><img src="./image-20220112140213884.png" alt="image-20220112140213884"></p>
<p>由上图可以看出记录头信息中共有5个字节的数据，记录头信息中各个属性的大体意思为（基于Compact 行格式）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">大小（单位：bit 位）</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">预留位1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">没有使用</td>
</tr>
<tr>
<td style="text-align:center">预留位2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">没有使用</td>
</tr>
<tr>
<td style="text-align:center">delete_mask</td>
<td style="text-align:center">1</td>
<td style="text-align:center">标记该记录是否被删除</td>
</tr>
<tr>
<td style="text-align:center">min_rec_mask</td>
<td style="text-align:center">1</td>
<td style="text-align:center">B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td style="text-align:center">n_owned</td>
<td style="text-align:center">4</td>
<td style="text-align:center">表示当前记录拥有的记录数</td>
</tr>
<tr>
<td style="text-align:center">heap_no</td>
<td style="text-align:center">13</td>
<td style="text-align:center">表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td style="text-align:center">record_type</td>
<td style="text-align:center">3</td>
<td style="text-align:center">表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶节点记录， 2 表示最小记录， 3表示最大记录</td>
</tr>
<tr>
<td style="text-align:center">next_record</td>
<td style="text-align:center">16</td>
<td style="text-align:center">表示下一条记录的相对位置</td>
</tr>
</tbody>
</table>
<p>下面，根据几个实例一起分析下</p>
<p><img src="./image-20220112140826146.png" alt="image-20220112140826146"></p>
<ul>
<li>
<p>delete_mask
这个属性标记着当前记录是否被删除，占用1个二进制位，<strong>值为0 的时候代表记录并没有被删除，为1 的时</strong>
<strong>候代表记录被删除掉了</strong>。这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的垃圾链表，在这个链表中的记录占用的空间称之为所谓的可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。</p>
</li>
<li>
<p>heap_no</p>
<p>这个属性表示当前记录在本页中的位置，从图中可以看出来，我们插入的4条记录在本页中的位置分别
是： 2 、3 、4 、5 。是不是少了点啥？是的，怎么不见heap_no 值为0 和1 的记录呢？这其实是设计InnoDB 的大叔们玩的一个小把戏，他们自动给每个页里边儿加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这两个伪记录一个代表最小记录，一个代表最大记录，等一下哈~，记录可以比大小么？是的，记录也可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是： 1 、2 、3 、4 ，这也就意味着这4条记录的大小从小到大依次递增。但是不管我们向页中插入了多少自己的记录，设计InnoDB 的大叔们都规定他们定义的两条伪记录分别为最小记录与最大记录。这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的，如图所示</p>
</li>
</ul>
<p><img src="./image-20220112141308901.png" alt="image-20220112141308901"></p>
<p>​	由于这两条记录不是我们自己定义的记录，所以它们并不存放在页的User Records 部分，他们被单独放在
​	一个称为Infimum + Supremum 的部分。</p>
<ul>
<li>
<p>next_record</p>
<p>它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record 值为32 ，意味着从第一条记录的真实数据的地址处向后找32 个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是， <strong>下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录</strong>。<strong>而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是 Supremum记录（也就是最大记录）</strong> ，为了更形象的表示一下这个next_record 起到的作用，我们用箭头来替代一下next_record 中的地址偏移量</p>
</li>
</ul>
<p><img src="./image-20220112141631745.png" alt="image-20220112141631745"></p>
<p>从图中可以看出来，<strong>我们的记录按照主键从小到大的顺序形成了一个单链表</strong>。最大记录的next_record 的
值为0 ，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉
一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p>
<p><img src="./image-20220112141731352.png" alt="image-20220112141731352"></p>
<p>从图中可以看出来，删除第2条记录前后主要发生了这些变化：</p>
<ol>
<li>
<p>第2条记录并没有从存储空间中移除，而是把该条记录的delete_mask 值设置为1</p>
</li>
<li>
<p>第2条记录的next_record 值变为了0，意味着该记录没有下一条记录了。</p>
</li>
<li>
<p>第1条记录的next_record 指向了第3条记录。</p>
</li>
<li>
<p>还有一点你可能忽略了，就是最大记录的n_owned 值从5 变成了4 ，关于这一点的变化我们稍后会详细说明的。所以，<strong>不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的</strong>。</p>
</li>
</ol>
<h4 id="page-directory页目录">Page Directory（页目录）</h4>
<p>现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某
条记录该咋办呢？比如说这样的查询语句：
SELECT * FROM page_demo WHERE c1 = 3;</p>
<p>我们平常想从一本书中查找某个内容的时候，一般会先看目录，找到需要查找的内容对应的书的页码，然后到对
应的页码查看内容。设计InnoDB 的大叔们为我们的记录也制作了一个类似的目录，他们的制作过程是这样的：</p>
<ol>
<li>将所有正常的记录（包括最大和最小记录，<strong>不包括标记为已删除的记录</strong>）划分为几个组。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的<strong>n_owned 属性表示该记录拥有多少条记</strong>
<strong>录，也就是该组内共有几条记录</strong>。</li>
<li><strong>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所</strong>
<strong>谓的Page Directory ，也就是页目录</strong>（此时应该返回头看看页面各个部分的图）。<strong>页面目录中的这些地址</strong>
<strong>偏移量被称为槽（英文名： Slot ），所以这个页面目录就是由槽组成的</strong>。</li>
</ol>
<p>比方说现在的page_demo 表中正常的记录共有6条， InnoDB 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录，看下边的示意图：</p>
<p><img src="./image-20220112142955993.png" alt="image-20220112142955993"></p>
<p>从这个图中我们需要注意这么几点：</p>
<ul>
<li>现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组， 槽1 中的值是112 ，代表最大记录
的地址偏移量（就是从页面的0字节开始数，数112个字节）； 槽0 中的值是99 ，代表最小记录的地址偏移
量。</li>
<li>注意最小和最大记录的头信息中的n_owned 属性
<ul>
<li>最小记录的n_owned 值为1 ，这就代表着以最小记录结尾的这个分组中只有1 条记录，也就是最小记录
本身。</li>
<li>最大记录的n_owned 值为5 ，这就代表着以最大记录结尾的这个分组中只有5 条记录，包括最大记录本
身还有我们自己插入的4 条记录。</li>
</ul>
</li>
</ul>
<p>用图表示就是：</p>
<p><img src="./image-20220112143150317.png" alt="image-20220112143150317"></p>
<p>为什么最小记录的n_owned 值为1，而最大记录的n_owned 值为5 呢，这里头有什么猫腻么？
是的，设计InnoDB 的大叔们对每个分组中的记录条数是有规定的：<strong>对于最小记录所在的分组只能有 1 条记录，</strong>
<strong>最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间</strong>。
所以分组是按照下边的步骤进行的：</p>
<ul>
<li>初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。</li>
<li>之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对
应的记录的n_owned 值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。</li>
<li>在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一
个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。</li>
</ul>
<p>了解了页目录的组成后，那么怎么就加快查找速度的过程呢？看下这个例子</p>
<p><img src="./image-20220112144050515.png" alt="image-20220112144050515"></p>
<p>比方说我们想找主键值为6 的记录，过程是这样的：</p>
<ol>
<li>计算中间槽的位置： (0+4)/2=2 ，所以查看槽2 对应记录的主键值为8 ，又因为8 &gt; 6 ，所以设置
high=2 ， low 保持不变。</li>
<li>重新计算中间槽的位置： (0+2)/2=1 ，所以查看槽1 对应的主键值为4 ，又因为4 &lt; 6 ，所以设置
low=1 ， high 保持不变。</li>
<li>因为high - low 的值为1，所以确定主键值为5 的记录在槽2 对应的组中。此刻我们需要找到槽2 中主键
值最小的那条记录，然后沿着单向链表遍历槽2 中的记录。但是我们前边又说过，每个槽对应的记录都是该
组中主键值最大的记录，这里槽2 对应的记录是主键值为8 的记录，怎么定位一个组中最小的记录呢？别忘
了各个槽都是挨着的，我们可以很轻易的拿到槽1 对应的记录（主键值为4 ），该条记录的下一条记录就
是槽2 中主键值最小的记录，该记录的主键值为5 。所以我们可以从这条主键值为5 的记录出发，遍历槽
2 中的各条记录，直到找到主键值为6 的那条记录即可。由于一个组中包含的记录条数只能是1~8条，所以
遍历一个组中的记录的代价是很小的。</li>
</ol>
<p>这就是典型的二分法哈哈，总结：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li>
<li>通过记录的next_record 属性遍历该槽所在的组中的各个记录。</li>
</ol>
<p><strong>这个就是索引为什么这么快的理由吗？？？</strong></p>
<h4 id="page-header页面头部">Page Header（页面头部）</h4>
<p>设计InnoDB 的大叔们为了能得到一个数据页中存储的记录的状态信息，比如本页中已经存储了多少条记录，第
一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫Page Header 的部分，它是
页结构的第二部分，这个部分占用固定的56 个字节，专门存储各种状态信息，具体各个字节都是干嘛的看下</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">占用空间大小</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PAGE_N_DIR_SLOTS</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">在页目录中的槽数量</td>
</tr>
<tr>
<td style="text-align:center">PAGE_HEAP_TOP</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td>
</tr>
<tr>
<td style="text-align:center">PAGE_N_HEAP</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td style="text-align:center">PAGE_FREE</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">第一个已经标记为删除的记录地址（各个已删除的记录通过next_record 也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td style="text-align:center">PAGE_GARBAGE</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">已删除记录占用的字节数</td>
</tr>
<tr>
<td style="text-align:center">PAGE_LAST_INSERT</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">最后插入记录的位置</td>
</tr>
<tr>
<td style="text-align:center">PAGE_DIRECTION</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">记录插入的方向</td>
</tr>
<tr>
<td style="text-align:center">PAGE_N_DIRECTION</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">一个方向连续插入的记录数量</td>
</tr>
<tr>
<td style="text-align:center">PAGE_N_RECS</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td style="text-align:center">PAGE_MAX_TRX_ID</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td style="text-align:center">PAGE_LEVEL</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">当前页在B+树中所处的层级</td>
</tr>
<tr>
<td style="text-align:center">PAGE_INDEX_ID</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td style="text-align:center">PAGE_BTR_SEG_LEAF</td>
<td style="text-align:center">10 字节</td>
<td style="text-align:center">B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td style="text-align:center">PAGE_BTR_SEG_TOP</td>
<td style="text-align:center">10 字节</td>
<td style="text-align:center">B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody>
</table>
<ul>
<li>PAGE_DIRECTION
<strong>假如新插入的一条记录的主键值比上一条记录的主键值大，我们说这条记录的插入方向是右边，反之则是左</strong>
<strong>边</strong>。用来表示最后一条记录插入方向的状态就是PAGE_DIRECTION 。</li>
<li>PAGE_N_DIRECTION
<strong>假设连续几次插入新记录的方向都是一致的， InnoDB 会把沿着同一个方向插入记录的条数记下来，这个条</strong>
<strong>数就用PAGE_N_DIRECTION 这个状态表示。当然，如果最后一条记录的插入方向改变了的话，这个状态的值</strong>
<strong>会被清零重新统计</strong>。</li>
</ul>
<h4 id="file-header文件头部">File Header（文件头部）</h4>
<p>​	Page Header 是专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的File Header 针对各种类型的页都通用，也就是说不同类型的页都会以File Header 作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页 这个部分占用固定的38 个字节，是由下边这些内容组成的</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">占用空间大小</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FIL_PAGE_SPACE_OR_CHKSUM</td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">页的校验和（checksum值）</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_OFFSET</td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">页号，InnoDB 通过页号来可以唯一定位一个页</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_PREV</td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">上一个页的页号</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_NEXT</td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">下一个页的页号</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_LSN</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">页面被最后修改时对应的日志序列位置（英文名是：Log SequenceNumber）</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_TYPE</td>
<td style="text-align:center">2 字节</td>
<td style="text-align:center">该页的类型</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_FILE_FLUSH_LSN</td>
<td style="text-align:center">8 字节</td>
<td style="text-align:center">仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td style="text-align:center">FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td style="text-align:center">4 字节</td>
<td style="text-align:center">页属于哪个表空间</td>
</tr>
</tbody>
</table>
<p>详解：</p>
<ul>
<li>
<p>FIL_PAGE_SPACE_OR_CHKSUM</p>
<p>这个代表当前页面的校验和（checksum）。啥是个校验和？就是对于一个很长很长的字节串来说，我们会
通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。这样在比
较两个很长的字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同
的，所以省去了直接比较两个比较长的字节串的时间损耗。</p>
</li>
<li>
<p>FIL_PAGE_TYPE</p>
<p>这个代表当前页的类型，我们前边说过， InnoDB 为了不同的目的而把页分为不同的类型，我们上边介绍的
其实都是存储记录的数据页，其实还有很多别的类型的页，我们存放记录的数据页的类型其实是FIL_PAGE_INDEX ，也就是所谓的索引页。</p>
</li>
<li>
<p>FIL_PAGE_PREV 和FIL_PAGE_NEXT</p>
<p>我们前边强调过， <strong>InnoDB 都是以页为单位存放数据的，有时候我们存放某种类型的数据占用的空间非常大</strong>
（比方说一张表中可以有成千上万条记录）， InnoDB 可能不可以一次性为这么多数据分配一个非常大的存
储空间，<strong>如果分散到多个不连续的页中存储的话需要把这些页关联起来</strong>， FIL_PAGE_PREV 和FIL_PAGE_NEXT
就分别代表本页的上一个和下一个页的页号。<strong>这样通过建立一个双向链表把许许多多的页就都串联起来了，</strong>
<strong>而无需这些页在物理上真正连着</strong></p>
</li>
</ul>
<p><img src="./image-20220112161911667.png" alt="image-20220112161911667"></p>
<h4 id="file-trailer">File Trailer</h4>
<p>我们知道InnoDB 存储引擎会把<strong>数据存储到磁盘</strong>上，但是<strong>磁盘速度太慢，需要以页为单位把数据加载到内存中处</strong>
<strong>理</strong>，<strong>如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中</strong>。但是在同步了一
半的时候中断电了咋办，这不是莫名尴尬么？为了检测一个页是否完整（也就是在同步的时候有没有发生只同步
一半的尴尬情况），设计InnoDB 的大叔们在每个页的尾部都加了一个File Trailer 部分，这个部分由8 个字
节组成，可以分成2个小部分：</p>
<ul>
<li>前4个字节代表页的校验和
这个部分是和<strong>File Header 中的校验和相对应的</strong>。每当一个页面在内存中修改了，在同步之前就要把它的校
验和算出来，因为File Header 在页面的前边，所以校验和会被首先同步到磁盘，<strong>当完全写完时，校验和也</strong>
<strong>会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的</strong>。如果写了一半儿断电
了，那么在File Header 中的校验和就代表着已经修改过的页，而在File Trialer 中的校验和代表着原先
的页，二者不同则意味着同步中间出了错。</li>
<li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）
这个部分也是为了校验页的完整性的</li>
</ul>
<p>这个File Trailer 与File Header 类似，都是所有<strong>类型的页通用的</strong>。</p>
<h4 id="总结">总结</h4>
<ol>
<li>InnoDB为了不同的目的而设计了<strong>不同类型的页</strong>，我们把用于存放记录的页叫做数据页。</li>
<li>一个数据页可以被大致划分为7个部分，分别是</li>
</ol>
<ul>
<li>File Header ，表示页的一些通用信息，占固定的38字节。</li>
<li>Page Header ，表示数据页专有的一些信息，占固定的56个字节。</li>
<li>Infimum + Supremum ，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26 个字节。
User Records ：真实存储我们插入的记录的部分，大小不固定。</li>
<li>Free Space ：页中尚未使用的部分，大小不确定。</li>
<li>Page Directory ：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插
入的记录越多，这个部分占用的空间越多。</li>
<li>File Trailer ：用于检验页是否完整的部分，占用固定的8个字节。</li>
</ul>
<ol start="3">
<li>每个记录的头信息中都有一个next_record 属性，<strong>从而使页中的所有记录串联成一个单链表</strong>。</li>
<li><strong>InnoDB 会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在</strong>
<strong>Page Directory 中，所以在一个页中根据主键查找记录是非常快的</strong>，分为两步：</li>
</ol>
<ul>
<li>通过二分法确定该记录所在的槽。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ul>
<ol start="5">
<li>每个数据页的File Header 部分都有上一个和下一个页的编号，所以<strong>所有的数据页会组成一个双链表</strong>。</li>
<li><strong>为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时</strong>
<strong>对应的LSN 值，如果首部和尾部的校验和和LSN 值校验不成功的话，就说明同步过程出现了问题</strong>。</li>
</ol>
<h2 id="深入研究b树索引">深入研究B+树索引</h2>
<p>前边我们详细唠叨了InnoDB 数据页的<strong>7个组成部分</strong>，知道了各个数据页可以组成一个<strong>双向链表</strong>，而每个数据页中的记录<strong>会按照主键值从小到大的顺序组成一个单向链表</strong>，每个数据页都会为存储在它里边儿的记录生成一个页目录，<strong>在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录</strong>。页和记录的关系示意图如下：</p>
<p><img src="./image-20220112163512527.png" alt="image-20220112163512527"></p>
<h3 id="没有索引的查找">没有索引的查找</h3>
<p>我们先了解一下没有索引的时候是怎么查找记录的。为了方便大家理解，我们下边先只唠叨搜索条件为对某个列精确匹配的情况，所谓精确匹配，就是搜索条件中用等于= 连接起的表达式，比如这样：</p>
<pre><code class="language-sql">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;
</code></pre>
<h4 id="在一个页中的查找">在一个页中的查找</h4>
<p>假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同
分为两种情况：</p>
<ul>
<li>以主键为搜索条件
这个查找过程我们已经很熟悉了，可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应
分组中的记录即可快速找到指定的记录。
以其他列作为搜索条件</li>
<li>对非主键列的查找的过程可就不这么幸运了，因为在数据页中并没有对非主键列建立所谓的页目录，所以
我们无法通过二分法快速定位相应的槽。<strong>这种情况下只能从最小记录开始依次遍历单链表中的每条记录，</strong>
<strong>然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的</strong>。</li>
</ul>
<h4 id="在很多页中查找">在很多页中查找</h4>
<p>大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话
可以分为两个步骤：</p>
<ol>
<li>定位到记录所在的页。</li>
<li>从所在的页内中查找相应的记录。</li>
</ol>
<p>在没有索引的情况下，<strong>不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的</strong>
<strong>页，所以只能从第一个页沿着双向链表一直往下找，在每一个页中根据我们刚刚唠叨过的查找方式去查找指定的</strong>
<strong>记录</strong>。<strong>因为要遍历所有的数据页</strong>，所以这种方式显然是超级耗时的。</p>
<h3 id="索引">索引</h3>
<p>新建一个index_demo 表，该表有2个INT 类型的列，1个CHAR(1) 类型的列，而且我们规定了c1 列为主键，这个表使用Compact 行格式来实际存储记录的。为了我们理解上的方便，我们简化了一下index_demo 表的行格式示
意图：</p>
<p><img src="./image-20220112165103356.png" alt="image-20220112165103356"></p>
<p>把一些记录放到页里边的示意图就是：</p>
<p><img src="./image-20220112165138344.png" alt="image-20220112165138344"></p>
<h4 id="一个简单的索引方案">一个简单的索引方案</h4>
<p>​	<strong>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢</strong>？<code>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页</code></p>
<p>​	所以如果我们想快速的定位到需要查找的记录在哪些数据页中该咋办？还记得我们<strong>为根据主键值快速定位一条记录在页中的位置而设立的页目录</strong>么？我们也可以想办法为快速定位记录所在的数据页而建立一个别的目录，建这个目录必须完成下边这些事儿：</p>
<ul>
<li>
<p>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</p>
<p>我们这里需要做一个假设：假设我们的每个数据页最多能存放3条记录（实际上一个
数据页非常大，可以存放下好多记录）。有了这个假设之后我们向index_demo 表插入3条记录：</p>
<pre><code class="language-sql">mysql&gt; INSERT INTO index_demo VALUES(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y');
</code></pre>
<p>那么这些记录已经按照主键值的大小串联成一个单向链表了，如图所示：</p>
</li>
</ul>
<p><img src="./image-20220112165538703.png" alt="image-20220112165538703"></p>
<p>此时我们再来插入一条记录:</p>
<pre><code class="language-sql">INSERT INTO index_demo VALUES(4, 4, 'a');
</code></pre>
<p>因为页10 最多只能放3条记录，所以我们不得不再分配<strong>一个新页</strong>：</p>
<p><img src="./image-20220112165642310.png" alt="image-20220112165642310"><strong>新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着</strong>。它们只是通过维护着上一个页和下一个页的编号而建立了链表关系</p>
<p>页10 中用户记录最大的主键值是5 ，而页28 中有一条记录的主键值是4 ，因为5&gt;4 ，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以<strong>在插入主键值为4 的记录的时候需要伴随着一次记录移动，也就是把主键值为5 的记录移动到页28 中，然后再把主键值为4 的记录插入到页10 中</strong>，这个过程的示意图如下:</p>
<p><img src="./image-20220112170056420.png" alt="image-20220112170056420"></p>
<p>这个过程表明了在对页中的记录进行增删改操作的过程中，我们必须通过一些诸如记录移动的操作来始终保
证这个状态一直成立：<strong>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值</strong>。这个过程
我们也可以称为<code>页分裂</code>。</p>
<ul>
<li>
<p>给所有的页建立一个目录项</p>
<p>由于<strong>数据页的编号可能并不是连续的</strong>，所以在向index_demo 表中插入许多条记录后，可能是这样的效果：</p>
</li>
</ul>
<p><img src="./image-20220112170338739.png" alt="image-20220112170338739"></p>
<p>​	因为这些16KB 的页在物理存储上可能并不挨着，所以如果想从这么多页中根据主键值快速定位某些记录所
在的页，<strong>我们需要给它们做个目录，每个页对应一个目录项</strong>，每个目录项包括下边两个部分：</p>
<ul>
<li>页的用户记录中最小的主键值，我们用key 来表示。</li>
<li>页号，我们用page_no 表示。</li>
</ul>
<p>所以我们为上边几个页做好的目录就像这样子：</p>
<p><img src="./image-20220112170501286.png" alt="image-20220112170501286"></p>
<p>以页28 为例，它对应目录项2 ，这个目录项中包含着该页的页号28 以及该页中用户记录的最小主键值5 。我们只需要把几个目录项在物理存储器上连续存储，比如把他们放到一个数组里，就可以实现根据主键值快速查找某条记录的功能了。比方说我们想找主键值为20 的记录，具体查找过程分两步：</p>
<ul>
<li>先从目录项中根据二分法快速确定出主键值为20 的记录在目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是页9 。</li>
<li>再根据前边说的<a href="#%E5%9C%A8%E4%B8%80%E4%B8%AA%E9%A1%B5%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE">在页中查找记录</a>的方式去页9 中定位具体的记录。</li>
</ul>
<p>至此，针对数据页做的简易目录就搞定了。不过忘了说了，这个<strong>目录</strong>有一个别名，称为<strong>索引</strong></p>
<h4 id="innodb中的索引方案">InnoDB中的索引方案</h4>
<p>上边之所以称为一个简易的<strong>索引方案</strong>，<em>是因为我们为了在根据主键值进行查找时使用二分法快速定位具体的目录</em>
<em>项而假设所有目录项都可以在物理存储器上连续存储</em>，但是这样做有几个问题：</p>
<ul>
<li>InnoDB 是使用<strong>页来作为管理存储空间的基本单位</strong>，也就是最多能保证16KB 的连续存储空间，而随着表中记录数量的增多，<strong>需要非常大的连续的存储空间才能把所有的目录项都放下，这对记录数量非常多的表是不现实的</strong>。</li>
<li>我们时常会对记录进行增删，<strong>假设我们把页28 中的记录都删除了</strong>， 页28 也就没有存在的必要了，<strong>那意味着目录项2 也就没有存在的必要了，这就需要把目录项2 后的目录项都向前移动一下</strong>，这种牵一发而动全身的设计不是什么好主意～</li>
</ul>
<p>所以，设计InnoDB 的大叔们需要一种可以灵活管理所有目录项的方式。他们灵光乍现，忽然发现这些<strong>目录项其实长得跟我们的用户记录差不多</strong>，只不过目录项中的两个列是主键和页号而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。那InnoDB 怎么区分一条记录是普通的用户记录还是目录项记录呢？别忘了记录头信息里的
record_type 属性，它的各个取值代表的意思如下：</p>
<ul>
<li>0 ：普通的用户记录</li>
<li>1 ：<strong>目录项记录</strong></li>
<li>2 ：最小记录</li>
<li>3 ：最大记录
哈哈，原来这个值为1 的record_type 是这个意思呀，我们把前边使用到的目录项放到数据页中的样子就是这
样：</li>
</ul>
<p><img src="./image-20220112171623872.png" alt="image-20220112171623872"></p>
<p>从图中可以看出来，我们<strong>新分配了一个编号为30 的页来专门存储目录项记录</strong>。这里再次强调一遍目录项记录
和普通的用户记录的不同点：</p>
<ul>
<li>目录项记录的record_type 值是1，而普通用户记录的record_type 值是0。</li>
<li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB 自己添加的隐藏列。</li>
<li>还记得我们之前在唠叨记录头信息的时候说过一个叫<a href="#%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%E7%9A%84%E7%A7%98%E5%AF%86">min_rec_mask</a> 的属性么，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask 值为1 ，其他别的记录的min_rec_mask 值都是0 。</li>
</ul>
<p>除了上述几点外，这两者就没啥差别了，它们用的是一样的数据页，页的组成结构也是一样一样的（就是我们前边介绍过的7个部分），都会为主键值生成Page Directory （页目录），从而在按照主键值进行查找时可以使用二分法来加快查询速度。现在以查找主键为20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:</p>
<ul>
<li>先到存储<strong>目录项记录</strong>的页，也就是页30 中通过二分法快速定位到对应目录项，因为12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9 。</li>
<li>再到存储<strong>用户记录</strong>的页9 中根据二分法快速定位到主键值为20 的用户记录</li>
</ul>
<p>虽然说目录项记录中只存储主键值和对应的页号，比用户记录需要的存储空间小多了，但是不论怎么说一个页只有16KB 大小，能存放的目录项记录也是有限的，那如果表中的数据太多，以至于一个数据页不足以存放所有的目录项记录，该咋办呢？</p>
<p>当然是再多整一个存储目录项记录的页喽～ 为了大家更好的理解新分配一个目录项记录页的过程，我们假设一个存储目录项记录的页最多只能存放4条目录项记录，所以如果此时我们再向上图中插入一条主键值为320 的用户记录的话，那就需要分配一个新的存储目录项记录的页喽：</p>
<p><img src="./image-20220112172433014.png" alt="image-20220112172433014"></p>
<p>从图中可以看出，我们插入了一条主键值为320 的用户记录之后需要两个新的数据页：</p>
<ul>
<li>为存储该用户记录而新生成了页31 。</li>
<li>因为原先存储目录项记录的页30 的容量已满（我们前边假设只能存储4条目录项记录），所以不得不需要一个新的页32 来存放页31 对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查
找主键值为20 的记录为例：</p>
<ol>
<li>确定目录项记录页
我们现在的存储目录项记录的页有两个，即页30 和页32 ，又因为页30 表示的目录项的主键值的范围是[1, 320) ， 页32 表示的目录项的主键值不小于320 ，所以主键值为20 的记录对应的目录项记录在页30中。</li>
<li>通过目录项记录页确定用户记录真实所在的页。</li>
<li>在真实存储用户记录的页中定位到具体的记录。</li>
</ol>
<p>那么问题来了，在这个查询步骤的第1步中我们需要<strong>定位存储目录项记录的页</strong>，但是这些页在存储空间中也可能不挨着，如果我们表中的数据非常多则会产生很多<strong>存储目录项记录的页</strong>，那我们怎么根据主键值快速定位一个
存储目录项记录的页呢？其实也简单，<strong>为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据</strong>，所以现在各个页的示意图就是这样子</p>
<p><img src="./image-20220112172841839.png" alt="image-20220112172841839"></p>
<p>如图，我们生成了一个存储更高级目录项的页33 ，这个页中的两条记录分别代表页30 和页32 ，如果用户记录的主键值在[1, 320) 之间，则到页30 中查找更详细的目录项记录，如果主键值不小于320 的话，就到页32中查找更详细的目录项记录。随着表中记录的增加，这个目录的层级会继续增加，如果简化一下，那么我们可以用下边这个图来描述它:</p>
<p><img src="./image-20220112173054335.png" alt="image-20220112173054335"></p>
<p><strong>这他妈的就是B+树了！！！</strong></p>
<p>更多b+树问题参考博文:</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653190965&amp;idx=1&amp;sn=53f78fa037386f85531832cd5322d2a0&amp;chksm=8c9909efbbee80f90512f0c36356c31cc74c388c46388dc2317d43c8f8597298f233ca9c29e9&amp;scene=21#wechat_redirect">什么是B树</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653191027&amp;idx=1&amp;sn=4ba22e3ec8bd149f69fc0aba72e4347e&amp;chksm=8c9909a9bbee80bfa1d8497ff0525df130414c1731b5aa5287bf16ea1cf86c8d8e6f20782184&amp;scene=21#wechat_redirect">什么是B+树</a></p>
<p><a href="https://www.cnblogs.com/nullzx/p/8729425.html">B树和B+树的插入、删除图文详解</a></p>
<p>不论是存放用户记录的数据页，还是存放目录项记录的数据页，我们都把它们存放到<strong>B+ 树</strong>这个数据结构中了，所以我们也称这些数据页为节点。从图中可以看出来，<strong>我们的实际用户记录其实都存放在B+树的最底层的节点上</strong>，<strong>这些节点也被称为叶子节点或叶节点</strong>，<strong>其余用来存放目录项的节点称为非叶子节点或者内节点，其中B+ 树最上边的那个节点也称为根节点</strong>。</p>
<p>从图中可以看出来，一个B+ 树的节点其实可以分成好多层，设计InnoDB 的大叔们为了讨论方便，规定最下边的那层，也就是存放我们用户记录的那层为<strong>第0 层</strong>，之后依次往上加。之前的讨论我们做了一个非常极端的假设：
存放用户记录的页最多存放3条记录，存放目录项记录的页最多存放4条记录。其实真实环境中一个页存放的记录
数量是非常大的，假设，假设，假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有
存放目录项记录的内节点代表的数据页可以存放1000条目录项记录，那么：</p>
<ul>
<li>如果B+ 树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100 条记录。</li>
<li>如果B+ 树有2层，最多能存放1000×100=100000 条记录。</li>
<li>如果B+ 树有3层，最多能存放1000×1000×100=100000000 条记录。</li>
<li>如果B+ 树有4层，最多能存放1000×1000×1000×100=100000000000 条记录。</li>
</ul>
<p>你的表里能存放100000000000 条记录么？所以一般情况下，<strong>我们用到的B+ 树都不会超过4层</strong>，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的Page Directory （页目录），所以在页面内也可以通过二分法实现快速定位记录。</p>
<h4 id="聚簇索引">聚簇索引</h4>
<p>我们上边介绍的B+ 树本身就是一个目录，或者说本身就是一个<strong>索引</strong>。它有两个特点：</p>
<ol>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</li>
</ol>
<ul>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成
一个双向链表。</li>
</ul>
<ol start="2">
<li>B+ 树的叶子节点存储的是完整的用户记录。
所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</li>
</ol>
<p><strong>我们把具有这两种特性的B+ 树称为聚簇索引</strong>，所有完整的用户记录都存放在这个<strong>聚簇索引的叶子节点</strong>处。这种聚簇索引并不需要我们在MySQL 语句中显式的使用INDEX 语句去创建（后边会介绍索引相关的语句），InnoDB 存储引擎会<strong>自动的为我们创建聚簇索引</strong>。另外有趣的一点是，在InnoDB 存储引擎中， <strong>聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引</strong>。</p>
<h4 id="二级索引">二级索引</h4>
<p>​	大家有木有发现，上边介绍的<strong>聚簇索引</strong>只能在<strong>搜索条件是主键值时</strong>才能发挥作用，因为B+ 树中的数据都是按照主键进行排序的。那如果我们想以别的列作为搜索条件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？
不，我们可以<strong>多建几棵B+ 树</strong>，不同的B+ 树中的数据采用不同的排序规则。比方说我们用c2 列的大小作为数据
页、页中记录的排序规则，再建一棵B+ 树，效果如下图所示：</p>
<p><img src="./image-20220112195520555.png" alt="image-20220112195520555"></p>
<p>这个B+ 树与上边介绍的聚簇索引有几处不同：</p>
<ul>
<li>使用记录c2 列的大小进行记录和页的排序，这包括三个方面的含义：
<ul>
<li>页内的记录是按照<strong>c2 列的大小</strong>顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中记录的<strong>c2 列大小</strong>顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的<strong>c2 列大小顺序</strong>排成一个双向链表。</li>
</ul>
</li>
<li>B+ 树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值。</li>
<li>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。</li>
</ul>
<p>所以如果我们现在想通过c2 列的值查找某些记录的话就可以使用我们刚刚建好的这个B+ 树了。以查找c2 列的值为4 的记录为例，查找过程如下：</p>
<ol>
<li>确定目录项记录页根据根页面，也就是页44 ，可以快速定位到目录项记录所在的页为页42 （因为2 &lt; 4 &lt; 9 ）。</li>
<li>通过目录项记录页确定用户记录真实所在的页。
在页42 中可以快速定位到实际存储用户记录的页，但是由于c2 列并没有唯一性约束，所以c2 列值为4 的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4 ，所以确定实际存储用户记录的页在页34 和页35 中。</li>
<li>在真实存储用户记录的页中定位到具体的记录。
到页34 和页35 中定位到具体的记录。</li>
<li>但是这个B+ 树的叶子节点中的记录只存储了c2 和c1 （也就是主键）两个列，所以<strong>我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录</strong>。</li>
</ol>
<p>我们根据这个以c2 列大小排序的B+ 树<strong>只能确定我们要查找记录的主键值</strong>，所以如果我们想根据c2 列的值查找到完整的用户记录的话，仍然需要到<strong>聚簇索引</strong>中再查一遍，这个过程也被称为<strong>回表</strong>。也就是根据c2 列的值查询一条完整的用户记录需要使用到2 棵B+ 树！！！</p>
<p>因为这种按照<strong>非主键列</strong>建立的<strong>B+ 树</strong>需要<strong>一次回表</strong>操作才可以定位到<strong>完整的用户记录</strong>，所以这种B+ 树也被称为<strong>二级索引</strong>（英文名secondary index ），或者辅助索引。由于我们使用的是c2 列的大小作为B+ 树的排序规则，所以我们也称这个B+ 树为为<strong>c2列建立的索引</strong>。</p>
<h4 id="联合索引">联合索引</h4>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为<strong>多个列建立索引</strong>，比方说我们想让B+ 树按照c2
和c3 列的大小进行排序，这个包含两层含义：</p>
<ul>
<li>先把各个记录和页按照c2 列进行排序。</li>
<li>在记录的c2 列相同的情况下，采用c3 列进行排序</li>
</ul>
<p><img src="./image-20220112200830399.png" alt="image-20220112200830399"></p>
<p>如图所示，我们需要注意一下几点：</p>
<ul>
<li>每条目录项记录都由<strong>c2 、c3 、页号</strong>这三个部分组成，各条记录先按照c2 列的值进行排序，如果记录的c2 列相同，则按照c3 列的值进行排序。</li>
<li>B+ 树叶子节点处的用户记录由<strong>c2 、c3 和主键c1 列</strong>组成。</li>
</ul>
<p>千万要注意一点，<strong>以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引</strong>。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</p>
<ul>
<li>建立联合索引只会建立如上图一样的1棵B+ 树。</li>
<li>为c2和c3列分别建立索引会分别以c2 和c3 列的大小为排序规则建立2棵B+ 树。</li>
</ul>
<h4 id="b树索引的注意事项">B+树索引的注意事项</h4>
<h5 id="根页面万年不动窝">根页面万年不动窝</h5>
<p>我们前边介绍B+ 树索引的时候，为了大家理解上的方便，先把存储用户记录的叶子节点都画出来，然后接着画
存储目录项记录的内节点，实际上B+ 树的形成过程是这样的：</p>
<ul>
<li>每当为某个表创建一个B+ 树索引（<strong>聚簇索引不是人为创建的，默认就有</strong>）的时候，都会为这个索引创建一个<strong>根节点页面</strong>。最开始表中没有数据的时候，每个B+ 树索引对应的根节点中既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到这个根节点中。</li>
<li>当根节点中的可用空间用完时继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如页a 中，然后对这个新页进行页分裂的操作，得到另一个新页，比如页b 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到页a 或者页b 中，而根节点便升级为存储目录项记录的页。</li>
</ul>
<p>这个过程需要大家特别注意的是：<strong>一个B+树索引的根节点自诞生之日起，便不会再移动</strong>。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB 存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。</p>
<h5 id="内节点中目录项记录的唯一性">内节点中目录项记录的唯一性</h5>
<p>我们知道B+ 树索引的内节点中目录项记录的内容是索引列 + 页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。还拿index_demo 表为例，假设这个表中的数据是这样的</p>
<table>
<thead>
<tr>
<th style="text-align:center">c1</th>
<th style="text-align:center">c2</th>
<th style="text-align:center">c3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&lsquo;u&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&rsquo;d'</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&lsquo;y&rsquo;</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&lsquo;a&rsquo;</td>
</tr>
</tbody>
</table>
<p>如果二级索引中目录项记录的内容只是索引列 + 页号的搭配的话，那么为c2 列建立索引后的B+ 树应该长这
样：</p>
<p><img src="./image-20220112202226583.png" alt="image-20220112202226583"></p>
<p>如果我们想新插入一行记录，其中c1 、c2 、c3 的值分别是： 9 、1 、&lsquo;c&rsquo; ，那么在修改这个为c2 列建立的二级索引对应的B+ 树时便碰到了个大问题：由于页3 中存储的目录项记录是由c2列 + 页号的值构成的，
页3 中的两条目录项记录对应的c2 列的值都是1 ，而我们新插入的这条记录的c2 列的值也是1 ，那我们这条新插入的记录到底应该放到页4 中，还是应该放到页5 中啊？</p>
<p>为了让新插入记录能找到自己在哪个页里，<strong>我们需要保证在B+树的同一层内节点的目录项记录除页号这个字段以外是唯一的</strong>。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的：</p>
<ul>
<li>索引列的值</li>
<li>主键值</li>
<li>页号</li>
</ul>
<p>也就是我们把<code>主键值</code>也添加到二级索引内节点中的<code>目录项记录</code>了，这样就能保证B+ 树每一层节点中各条目录项记录除<code>页号</code>这个字段外是唯一的，所以我们为c2 列建立二级索引后的示意图实际上应该是这样子的</p>
<p><img src="./image-20220112202541069.png" alt="image-20220112202541069"></p>
<h5 id="一个页面最少存储2条记录">一个页面最少存储2条记录</h5>
<p>​	我们前边说过一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度杠杠的！<strong>这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录</strong>。<strong>那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录</strong>。所以InnoDB 的一个数据页至少可以存放两条记录，这也是我们之前唠叨记录行格式的时候说过一个结论（我们当时依据这个结论推导了表中只有一个列时该列在不发生行溢出的情况下最多能存储多少字节，忘了的话回去看看吧）。</p>
<h4 id="myisam中的索引方案简单介绍">MyISAM中的索引方案简单介绍</h4>
<p>​	至此，我们介绍的都是InnoDB 存储引擎中的索引方案，我们有必要再简单介绍一下MyISAM 存储引擎中的索引方案。我们知道InnoDB 中<strong>索引即数据</strong>，也就是聚<strong>簇索引的那棵B+ 树的叶子节点中已经把所有完整的用户记录都包含了</strong>，而MyISAM 的索引方案虽然也使用树形结构，但是却将索引和数据分开存储：</p>
<ul>
<li><strong>将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件。这个文件并不划分为若干个</strong>
<strong>数据页，有多少记录就往这个文件中塞多少记录就成了</strong>。<strong>我们可以通过行号而快速访问到一条记录</strong>。
MyISAM 记录也需要记录头信息来存储一些额外数据，我们以上边唠叨过的index_demo 表为例，看一下这个
表中的记录使用MyISAM 作为存储引擎在存储空间中的表示：</li>
</ul>
<p><img src="./image-20220112203638552.png" alt="image-20220112203638552"></p>
<p>​	由于在插入数据的时候并没有刻意按照主键大小排序，所以我们并不能在这些数据上使用二分法进行查找。</p>
<ul>
<li>
<p>使用MyISAM 存储引擎的表会把<strong>索引信息另外存储到一个称为索引文件的另一个文件中</strong>。<strong>MyISAM 会单独为</strong>
<strong>表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号的组</strong>
<strong>合。<strong>也就是先通过索引找到对应的行号，再通过行号去找对应的记录！
这一点和InnoDB 是完全不相同的，<strong>在InnoDB 存储引擎中，我们只需要根据主键值对聚簇索引进行一次查</strong>
<strong>找就能找到对应的记录</strong>，而在</strong>MyISAM 中却需要进行一次回表操作，意味着MyISAM 中建立的索引相当于全</strong>
<strong>部都是二级索引</strong></p>
</li>
<li>
<p>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB 中的索引差不
多，不过在叶子节点处存储的是相应的列 + 行号。这些索引也全部都是二级索引</p>
</li>
</ul>
<h4 id="mysql中创建和删除索引的语句">MySQL中创建和删除索引的语句</h4>
<p>建表时</p>
<pre><code class="language-sql">CREATE TALBE 表名 (
各种列的信息 ··· ,
[KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)
</code></pre>
<p>其中的KEY 和INDEX 是同义词，任意选用一个就可以</p>
<p>添加索引</p>
<pre><code class="language-sql">ALTER table tableName ADD INDEX indexName(columnName)
</code></pre>
<p>删除索引</p>
<pre><code class="language-sql">ALTER TABLE 表名 DROP [INDEX|KEY] 索引名
</code></pre>
<p>索引名建议：以idx_ 为前缀，后边跟着需要建立索引的列名，多个列名之间用下划线_ 分隔开。</p>
<h3 id="b树索引的使用">B+树索引的使用</h3>
<hr>
<p>B+ 树索引总结:</p>
<ul>
<li>每个索引都对应一棵B+ 树， B+ 树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+ 树的叶子节点，所有目录项记录都存储在内节点。</li>
<li>InnoDB 存储引擎会自动为<strong>主键</strong>（如果没有它会自动帮我们添加）建立<strong>聚簇索引</strong>，<strong>聚簇索引的叶子节点包含完整的用户记录</strong>。</li>
<li>我们可以为自己感兴趣的列建立二级索引， 二级索引的叶子节点包含的用户记录由<strong>索引列 + 主键</strong>组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过<strong>回表</strong>操作，<strong>也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录</strong>。</li>
<li>B+ 树中每层节点都是按照索引列值<code>从小到大</code>的顺序排序而组成了<strong>双向链表</strong>，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照<strong>索引列的值从小到大的顺序而形成了一个单链表</strong>。如果是联合索引的话，则页面和记录先按照<strong>联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序</strong>。</li>
<li>通过索引查找记录是从B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory （页目录），所以在这些页面中的查找非常快。</li>
</ul>
<h4 id="索引的代价">索引的代价</h4>
<hr>
<ol>
<li>空间上的代价
这个是显而易见的，每<strong>建立一个索引都要为它建立一棵B+ 树</strong>，每一棵B+ 树的每一个节点都是一个数据页，一个页默认会占用16KB 的存储空间，一棵很大的B+ 树由许多数据页组成，那可是很大的一片存储空间呢。</li>
<li>时间上的代价
每次对表中的数据进行增、删、改操作时，都需要去修改各个B+ 树索引。而且我们讲过， B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而
增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的B+ 树都要进行相关的维护操作，这还能不给性能拖后腿么？</li>
</ol>
<p>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。</p>
<h4 id="b树索引适用的条件">B+树索引适用的条件</h4>
<hr>
<p>下边我们将唠叨许多种让B+ 树索引发挥最大效能的技巧和注意事项，先创建一个person_info表，这个表是用来存储人的一些基本信息的：</p>
<pre><code class="language-sql">CREATE TABLE person_info(
id INT NOT NULL auto_increment,
name VARCHAR(100) NOT NULL,
birthday DATE NOT NULL,
phone_number CHAR(11) NOT NULL,
country varchar(100) NOT NULL,
PRIMARY KEY (id),
KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
</code></pre>
<p>对于这个person_info 表我们需要注意两点：</p>
<ul>
<li>表中的主键是id 列，它存储一个自动递增的整数。所以InnoDB 存储引擎会自动为id 列建立<strong>聚簇索引</strong>。</li>
<li>我们额外定义了一个二级索引idx_name_birthday_phone_number ，它是由3个列组成的<strong>联合索引</strong>。所以在这个索引对应的B+ 树的叶子节点处存储的用户记录只保留name 、birthday 、phone_number 这三个列的值以及主键id 的值，并不会保存country 列的值。</li>
</ul>
<p>person_info 表会为聚簇索引和idx_name_birthday_phone_number 索引建立<strong>2棵B+ 树</strong>。下边我们画一下索引idx_name_birthday_phone_number 的示意图，不过既然我们已经掌握了InnoDB 的B+ 树索引原理，那我们在画图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留name 、birthday 、phone_number 、id 这四个列的真实数据值</p>
<p><img src="image-20220113145903575.png" alt="image-20220113145903575"></p>
<p>从图中可以看出这个idx_name_birthday_phone_number 索引对应的B+ 树中页面和记录的排序方式就是这的：</p>
<ul>
<li>先按照name 列的值进行排序。</li>
<li>如果name 列的值相同，则按照birthday 列的值进行排序。</li>
<li>如果birthday 列的值也相同，则按照phone_number 的值进行排序</li>
</ul>
<h5 id="全值匹配">全值匹配</h5>
<hr>
<p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配,例如：</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
</code></pre>
<p>这个毫无疑问会走索引，但WHERE 子句中的几个搜索条件的顺序对查询结果有啥影响么？也就是说如果我们调换name 、birthday 、phone_number 这几个搜索列的顺序对查询的执行过程有影响么？例如：</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE birthday = '1990-09-27' AND phone_number = '15123983239' AND name = 'Ashburn';
</code></pre>
<p>答案是：没影响哈。MySQL 有<strong>查询优化器</strong>，会分析这些<strong>搜索条件</strong>并且<strong>按照可以使用的索引中列的顺序来决定先使用哪个搜索条件，后使用哪个搜索条件</strong>。</p>
<h5 id="匹配左边的列">匹配左边的列</h5>
<hr>
<p>其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'Ashburn';
或者包含多个左边的列也行：
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';
</code></pre>
<p>那这条查询语句能用到索引吗？</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE birthday = '1990-09-27';
</code></pre>
<p>答案是用不到，<strong>因为B+ 树的数据页和记录先是按照name 列的值排序的，在name 列的值相同的情况下才使用birthday 列进行排序，也就是说name 列的值不同的记录中birthday 的值可能是无序的</strong>需要特别注意的一点是，<strong>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边开始连续的列</strong>。比方说联合索引idx_name_birthday_phone_number 中列的定义顺序是name 、birthday 、phone_number ，如果我们的搜索条件中只有name 和phone_number ，而没有中间的birthday ，比方说这样：</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
</code></pre>
<p>这样只能用到name 列的索引， birthday 和phone_number 的索引就用不上了，因为name 值相同的记录先按照birthday 的值进行排序， birthday 值相同的记录才按照phone_number 值进行排序</p>
<h5 id="匹配列前缀">匹配列前缀</h5>
<hr>
<p>为某个列建立索引的意思其实就是在<strong>对应的B+ 树的记录中使用该列的值进行排序</strong>，比方说person_info 表上建立的联合索引idx_name_birthday_phone_number 会先用name 列的值进行排序，字符串排序使用的当然就是字典序，<strong>也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的</strong>，例如：</p>
<pre><code class="language-sql">走索引 SELECT * FROM person_info WHERE name LIKE 'As%';
不走索引 SELECT * FROM person_info WHERE name LIKE '%As%';
</code></pre>
<h5 id="匹配范围值">匹配范围值</h5>
<hr>
<p>idx_name_birthday_phone_number 索引的B+ 树示意图，所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow';
</code></pre>
<p>由于B+ 树中的数据页和记录是先按name 列排序的，所以我们上边的查询过程其实是这样的：</p>
<ul>
<li>找到name 值为Asa 的记录(查找到范围的下限)。</li>
<li>遍历链表找到name 值为Barlow 的记录（查找到范围的上限）由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表）</li>
<li>找到这些记录的主键值，再到<strong>聚簇索引</strong>中<strong>回表</strong>查找完整的记录。</li>
</ul>
<p>注意</p>
<p><strong>如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到B+ 树索引</strong>，</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow' AND birthday &gt; '1980-01-01';
</code></pre>
<p>上边这个查询可以分成两个部分：</p>
<ol>
<li>通过条件name &gt; &lsquo;Asa&rsquo; AND name &lt; &lsquo;Barlow&rsquo; 来对name 进行范围，查找的结果可能有<strong>多条name 值不同的</strong>
<strong>记录</strong></li>
<li>对这些name 值不同的记录继续通过birthday &gt; &lsquo;1980-01-01&rsquo; 条件继续过滤。
这样子对于联合索引idx_name_birthday_phone_number 来说，只能用到name 列的部分，而用不到birthday 列的部分，因为只有name 值相同的情况下才能用birthday 列的值进行排序，<strong>而这个查询中通过name 进行范围查找的记录中可能并不是按照birthday 列进行排序的</strong>，所以在搜索条件中继续以birthday 列进行查找时是用不到这个B+ 树索引的。</li>
</ol>
<p>而与上面相反的是，<strong>精确匹配某一列并范围匹配另外一列</strong>,如</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday &gt; '1980-01-01' AND birthday &lt; '2000-12-31' AND phone_number &gt; '15100000000';
</code></pre>
<p>这个查询的条件可以分为3个部分：</p>
<ol>
<li>name = &lsquo;Ashburn&rsquo; ，对name 列进行精确查找，当然可以使用B+ 树索引了。</li>
<li>birthday &gt; &lsquo;1980-01-01&rsquo; AND birthday &lt; &lsquo;2000-12-31&rsquo; ，由于<strong>name 列是精确查找</strong>，所以通过name =&lsquo;Ashburn&rsquo; 条件查找后得到的结果的name 值都是相同的，它们会再按照birthday 的值进行排序。所以此时对<strong>birthday 列进行范围查找是可以用到B+ 树索引的</strong>。</li>
<li>phone_number &gt; &lsquo;15100000000&rsquo; ，通过birthday 的范围查找的记录的birthday 的值可能不同，<strong>所以这个条件无法再利用B+ 树索引了，只能遍历上一步查询得到的记录</strong>。</li>
</ol>
<h5 id="用于排序">用于排序</h5>
<hr>
<p>我们在写查询语句的时候经常需要对查询出来的记录通过ORDER BY 子句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在<strong>内存</strong>中对这些记录进行排序，有的时候可能查询的结果集太大以至于不能在内存中进行排序的话，还可能暂时借助<strong>磁盘</strong>的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。在MySQL 中，<strong>把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名： filesort ）</strong>，文件排序是很慢的。但是如果ORDER BY 子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤，比如下边这个简单的查询语句</p>
<pre><code class="language-sql">SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
</code></pre>
<p>因为有idx_name_birthday_phone_number 索引，所以直接从<strong>索引中提取数据</strong>，然后进行<strong>回表</strong>操作取出所有数据</p>
<p>对于联合索引有个问题需要注意， ORDER BY 的子句后边的列的顺序也必须按照索引列的顺序给出，否则也不能使用索引，同理， ORDER BY name 、ORDER BY name, birthday 这种匹配索引左边的列的形式可以使用部分的B+ 树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
</code></pre>
<h5 id="不可以使用索引进行排序的几种情况">不可以使用索引进行排序的几种情况</h5>
<hr>
<h6 id="ascdesc混用">ASC、DESC混用</h6>
<p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC 规则
排序，要么都是DESC 规则排序。</p>
<p>如果查询中的各个排序列的排序顺序是一致的，比方说下边这两种情况：</p>
<ul>
<li>ORDER BY name, birthday LIMIT 10
这种情况直接从索引的最左边开始往右读10行记录就可以了。</li>
<li>ORDER BY name DESC, birthday DESC LIMIT 10 ，
这种情况直接从索引的最右边开始往左读10行记录就可以了。</li>
</ul>
<p>但是是先按照name 列进行升序排列，再按照birthday 列进行降序排列的话，比如说这样的查询语句：</p>
<pre><code class="language-sql">SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;
</code></pre>
<p>就不能走索引</p>
<h6 id="where子句中出现非排序使用到的索引列">WHERE子句中出现非排序使用到的索引列</h6>
<pre><code class="language-sql">SELECT * FROM person_info WHERE country = 'China' ORDER BY name LIMIT 10;
</code></pre>
<p>这个查询只能先把符合搜索条件country = &lsquo;China&rsquo; 的记录提取出来后再进行排序，使用不到索引。</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;
</code></pre>
<p>虽然这个查询也有搜索条件，但是name = &lsquo;A&rsquo; 可以使用到索引idx_name_birthday_phone_number ，而且过滤剩
下的记录还是按照birthday 、phone_number 列排序的，所以还是可以使用索引进行排序的</p>
<h6 id="排序列包含非同一个索引的列">排序列包含非同一个索引的列</h6>
<p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p>
<pre><code class="language-sql">SELECT * FROM person_info ORDER BY name, country LIMIT 10;
</code></pre>
<p>name 和country (即使country为索引列也不行)并不属于一个联合索引中的列，所以无法使用索引进行排序</p>
<h6 id="排序列使用了复杂的表达式">排序列使用了复杂的表达式</h6>
<pre><code class="language-sql">SELECT * FROM person_info ORDER BY UPPER(name) LIMIT 10;
</code></pre>
<p>使用了UPPER 函数修饰过的列就不是单独的列了，这样就无法使用<strong>索引</strong>进行排序。</p>
<h5 id="用于分组">用于分组</h5>
<pre><code class="language-sql">SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
</code></pre>
<p>和使用B+ 树索引进行排序使用规则相同，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组等</p>
<h4 id="回表的代价">回表的代价</h4>
<hr>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow';
</code></pre>
<p>在使用idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤：</p>
<ol>
<li>从索引idx_name_birthday_phone_number 对应的B+ 树中取出name 值在Asa ～ Barlow 之间的用户记录。</li>
<li>由于索引idx_name_birthday_phone_number 对应的B+ 树用户记录中只包含name 、birthday 、
phone_number 、id 这4个字段，而查询列表是* ，意味着要查询表中所有字段，也就是还要包括country
字段。这时需要把从上一步中获取到的每一条记录的id 字段都到<strong>聚簇索引</strong>对应的B+ 树中找到<strong>完整的用户记录</strong>，也就是我们通常所说的<strong>回表</strong>，然后把完整的用户记录返回给查询用户。</li>
</ol>
<p>由于索引idx_name_birthday_phone_number 对应的B+ 树中的记录首先会按照name 列的值进行排序，所以值在Asa ～ Barlow 之间的记录在<strong>磁盘中的存储是相连的，集中分布在一个或几个数据页中</strong>，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为<code>顺序I/O</code>。根据第1步中获取到的记录的id 字段的值可能并不相连，而在<strong>聚簇索引中记录是根据id （也就是主键）的顺序排列的</strong>，所以根据这些并不连续的id值到聚簇索引中访问完整的用户记录可能<strong>分布在不同的数据页中</strong>，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为<strong>随机I/O</strong> 。一般情况下，<strong>顺序I/O</strong>比<strong>随机I/O</strong>的性能高很多。所以这个使用索引idx_name_birthday_phone_number 的查询有这么两个特点：</p>
<ul>
<li>会使用到两个B+ 树索引，一个二级索引，一个聚簇索引。</li>
<li>访问二级索引使用顺序I/O ，访问聚簇索引使用随机I/O 。</li>
</ul>
<p><strong>需要回表的记录越多，使用二级索引的性能就越低</strong>，甚至让某些查询宁愿使用<strong>全表扫描</strong>也不使用<strong>二级索引</strong>。比方说name 值在Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用idx_name_birthday_phone_number 索引的话，有90%多的id 值需要回表，还不如直接去扫描聚簇索引（也就是全表扫描）。</p>
<p>那什么时候采用全表扫描的方式，什么时候使用采用二级索引 + 回表的方式去执行查询呢？</p>
<p><strong>查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式</strong>。</p>
<p>一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用二级索引 + 回表的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：</p>
<pre><code class="language-sql">SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow' LIMIT 10;
同样排序也可以：SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
</code></pre>
<h5 id="覆盖索引">覆盖索引</h5>
<p>为了彻底告别回表操作带来的性能损耗，最好在查询列表里只包含索引列，比如：</p>
<pre><code class="language-sql">SELECT name, birthday, phone_number FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlo
w'
</code></pre>
<p>因为只查询name , birthday , phone_number 这三个索引列的值，所以通idx_name_birthday_phone_number 索引得到结果后就不必到聚簇索引中再查找记录的剩余列，这样就省去了<strong>回表</strong>操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为<code>索引覆盖</code>,所以坚决不能用* 号作为查询列表，最好把我们需要查询的列依次标明。</p>
<h4 id="如何挑选索引">如何挑选索引</h4>
<hr>
<h5 id="只为用于搜索排序或分组的列创建索引">只为用于搜索、排序或分组的列创建索引</h5>
<p>只为出现在WHERE 子句中的列、连接子句中的连接列，或者出现在ORDER BY 或GROUP BY 子句中的
列创建索引。而出现在查询列表中的列就没必要建立索引了</p>
<h5 id="考虑列的基数">考虑列的基数</h5>
<p><strong>列的基数</strong>指的是某一列中不重复数据的个数，比方说某个列包含值2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有9 条记录，但该列的基数却是3 。也就是说，在记录行数一定的情况下，<strong>列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中</strong>。假设某个列的基数为1 ，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了，而且如果某个建立了<strong>二级索引的列的重复值特别多</strong>，那么使用这个二级索引查出的记录还可能要做<strong>回表</strong>操作，这样性能损耗就更大了。</p>
<p>所以结论就是：<strong>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好</strong>（索引尽量建在数据重复不多的列上，比如XX_id,但XX_time上则不合适）</p>
<h5 id="索引列的类型尽量小">索引列的类型尽量小</h5>
<p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TINYINT 、MEDIUMINT 、INT 、BIGINT
这么几种，它们占用的存储空间依次递增，我们这里所说的<strong>类型大小</strong>指的就是<strong>该类型表示的数据范围的大小</strong>。
能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，<strong>在表示的整数范围允许的情况</strong>
<strong>下，尽量让索引列使用较小的类型</strong>，比如我们能使用INT 就不要使用BIGINT ，能使用MEDIUMINT 就不要使用
INT ～ 这是因为：</p>
<ul>
<li>数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少<strong>磁盘I/O</strong> 带
来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ul>
<p>这个建议对于表的主键来说更加适用，因为不仅是<strong>聚簇索引中会存储主键值</strong>，其他所有的二级索引的节点处都会
<strong>存储一份记录的主键值</strong>，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的I/O</p>
<h5 id="索引字符串值的前缀">索引字符串值的前缀</h5>
<p><strong>只对字符串的前几个字符进行索引</strong>也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，<strong>然后根据前缀相同的记录的主键值回表查询完整的字符串值</strong>，再对比就好了。这样只在B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，比方说我们在建表语句中只对name 列的前10个字符进行索引可以这么写：</p>
<pre><code class="language-sql">CREATE TABLE person_info(
name VARCHAR(100) NOT NULL,
birthday DATE NOT NULL,
phone_number CHAR(11) NOT NULL,
country varchar(100) NOT NULL,
KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);
</code></pre>
<p>name(10) 就表示在建立的B+ 树索引中只保留记录的前10 个字符的编码，这种只索引字符串值的前缀的策略是
我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p>
<pre><code class="language-sql">SELECT * FROM person_info ORDER BY name LIMIT 10;
</code></pre>
<p>因为二级索引中不包含完整的name 列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也
就是使用索引列前缀的方式无法支持使用<strong>索引排序</strong>，只好乖乖的用文件排序喽。</p>
<h5 id="让索引列在比较表达式中单独出现">让索引列在比较表达式中单独出现</h5>
<p>假设表中有一个整数列my_col ，我们为这个列建立了索引。下边的两个WHERE 子句虽然语义是一致的，但是在
效率上却有差别：</p>
<ol>
<li>WHERE my_col * 2 &lt; 4</li>
<li>WHERE my_col &lt; 4/2</li>
</ol>
<p>第1个WHERE 子句中my_col 列并不是以单独列的形式出现的，而是以my_col * 2 这样的表达式的形式出现的，
<strong>存储引擎会依次遍历所有的记录，计算这个表达式的值是不是小于4</strong> ，所以这种情况下是使用不到为my_col 列
建立的B+ 树索引的。而第2个WHERE 子句中my_col 列并是以单独列的形式出现的，这样的情况可以直接使用
B+ 树索引。
所以结论就是：<strong>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出</strong>
<strong>现的话，是用不到索引的</strong>。</p>
<h5 id="主键插入顺序">主键插入顺序</h5>
<p>我们知道，对于一个使用InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<strong>聚簇索引</strong>的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在1~100 之间：</p>
<p><img src="image-20220113172305129.png" alt="image-20220113172305129"></p>
<p>如果此时再插入一条主键值为9 的记录，那它插入的位置就如下图：</p>
<p><img src="image-20220113172317389.png" alt="image-20220113172317389"></p>
<p>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：性能损耗！所以如果我们想尽量避免这样无谓的性能损耗最好<strong>让插入的记录的主键值依次递增</strong></p>
<h5 id="冗余和重复索引">冗余和重复索引</h5>
<p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p>
<pre><code class="language-sql">CREATE TABLE person_info(
id INT UNSIGNED NOT NULL AUTO_INCREMENT,
name VARCHAR(100) NOT NULL,
birthday DATE NOT NULL,
phone_number CHAR(11) NOT NULL,
country varchar(100) NOT NULL,
PRIMARY KEY (id),
KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
KEY idx_name (name(10))
);
</code></pre>
<p>通过idx_name_birthday_phone_number 索引就可以对name 列进行快速搜索，再创建一个专门针对name 列的索引就算是一个冗余索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。<strong>这个自己也犯过</strong></p>
<h4 id="总结-1">总结</h4>
<ol>
<li>
<p>B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</p>
</li>
<li>
<p>B+ 树索引适用于下边这些情况：</p>
<ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
</li>
<li>
<p>在使用索引时需要注意下边这些事项：</p>
<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，主键一定要依次递增。</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用覆盖索引进行查询，避免回表带来的性能损耗。</li>
</ul>
</li>
</ol>
<h2 id="innodb的表空间">InnoDB的表空间</h2>
<p><strong>表空间</strong>是一个抽象的概念，对于系统表空间来说，对应着文件系统中一个或多个实际文件；对于每个独立表空间来说，对应着文件系统中一个名为表名.ibd 的实际文件。大家可以把表空间想象成被切分为许许多多个页的池子，当我们想为某个表插入一条记录的时候，就从池子中捞出一个对应的页来把数据写进去。</p>
<h3 id="独立表空间结构">独立表空间结构</h3>
<hr>
<p>InnoDB 支持许多种类型的表空间，重点关注独立表空间和系统表空间的结构。它们的结构比较相似。</p>
<h4 id="区extent的概念">区（extent）的概念</h4>
<hr>
<p>表空间中的页实在是太多了，为了更好的管理这些页面，提出了区（英文名： extent ）的概念。<strong>对于16KB的页来说，连续的64个页就是一个区，也就是说一个区默认占用1MB空间大小</strong>。不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，<strong>每256个区被划分成一组</strong></p>
<p><img src="image-20220114113807990.png" alt="image-20220114113807990"></p>
<p>这些组的头几个页面的类型都是类似的，就像这样</p>
<p><img src="image-20220114113904914.png" alt="image-20220114113904914"></p>
<p>从上图中我们能得到如下信息：</p>
<ul>
<li>第一个组最开始的3个页面的类型是固定的，也就是说extent 0 这个区最开始的3个页面的类型是固定的，
分别是：
<ul>
<li>FSP_HDR 类型：这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，也就是extent 0 ~ extent 255 这256个区的属性，稍后详细唠叨。需要注意的一点是，整个表空间只有一个FSP_HDR 类型的页面。</li>
<li>IBUF_BITMAP 类型：这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER 的信息。</li>
<li>INODE 类型：这个类型的页面存储了许多称为INODE 的数据结构。</li>
</ul>
</li>
<li>其余各组最开始的2个页面的类型是固定的，也就是说extent 256 、extent 512 这些区最开始的2个页面
的类型是固定的，分别是：
<ul>
<li>XDES 类型：全称是extent descriptor ，用来登记本组256个区的属性，也就是说对于在extent 256
区中的该类型页面存储的就是extent 256 ~ extent 511 这些区的属性，对于在extent 512 区中的该
类型页面存储的就是extent 512 ~ extent 767 这些区的属性。上边介绍的FSP_HDR 类型的页面其实
和XDES 类型的页面的作用类似，只不过FSP_HDR 类型的页面还会额外存储一些表空间的属性。</li>
<li>IBUF_BITMAP 类型：上边介绍过了。</li>
</ul>
</li>
</ul>
<p>总之，<strong>表空间被划分为许多连续的区，每个区默认由64个页组成，每256个区划分为一组，每个组的最开始的几个页面类型是固定的</strong></p>
<h4 id="段segment的概念">段（segment）的概念</h4>
<hr>
<p>为啥好端端的提出一个区（ extent ）的概念呢？我们以前分析问题的套路都是这样的：表中的记录存储到页里
边儿，然后页作为节点组成B+ 树，这个B+ 树就是索引，但我们来考虑一下下边这个场景：</p>
<ul>
<li>我们每向表中插入一条记录，<strong>本质上就是向该表的聚簇索引以及所有二级索引代表的B+ 树的节点中插入数</strong>
<strong>据</strong>。而B+ 树的每一层中的页都会形成一个双向链表，<strong>如果是以页为单位来分配存储空间的话，双向链表相</strong>
<strong>邻的两个页之间的物理位置可能离得非常远</strong>。我们介绍B+ 树索引的适用场景的时候特别提到<strong>范围查询只需</strong>
<strong>要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了</strong>，而如果链表中相邻的两个页
物理位置离得非常远，就是所谓的<strong>随机I/O</strong> 。再一次强调，磁盘的速度和内存的速度差了好几个数量级， 随
机I/O 是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可
以使用所谓的<strong>顺序I/O</strong></li>
</ul>
<p>所以才引入了区（ extent ）的概念，<strong>一个区就是在物理位置上连续的64个页</strong>。。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是<strong>按照区为单位分配</strong>，甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。</p>
<p>我们提到的范围查询，其实是对<strong>B+ 树叶子节点</strong>中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以设计InnoDB 的大叔们对B+ 树的<strong>叶子节点</strong>和<strong>非叶子节点</strong>进行了区别对待，也就是说叶子节点有自己独有的<strong>区</strong>，非叶子节点也有自己独有的<strong>区</strong>。<strong>存放叶子节点的区的集合就算是一个段（ segment ）</strong>，<strong>存放非叶子节点的区的集合也算是一个段</strong>。<strong>也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段</strong>。</p>
<p>默认情况下一个使用InnoDB 存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存
储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？
以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。设计InnoDB 的大叔们提出了一个<strong>碎片（fragment）区</strong>的概念，也就是在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于<strong>表空间</strong>，并不属于任何一个<strong>段</strong>。所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合</p>
<h4 id="区的分类">区的分类</h4>
<hr>
<p>表空间是由若干个区组成的，这些区大体上可以分为4种类型：</p>
<ul>
<li>空闲的区（Free）：现在还没有用到这个区中的任何页面。</li>
<li>有剩余空间的碎片区(FREE_FRAG)：表示碎片区中还有可用的页面。</li>
<li>没有剩余空间的碎片区(FULL_FRAG)：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li>附属于某个段的区(FSEG)。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。</li>
</ul>
<p>这4种类型的区也可以被称为区的4种状态（ Free、FREE_FRAG、FULL_FRAG、FSEG）,处于FREE 、FREE_FRAG 以及FULL_FRAG 这三种状态的区都是独立的，算是直属于<strong>表空间</strong>；而处于FSEG 状态的区是附属于某个段的</p>
<blockquote>
<p>如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像
是处于<code>FSEG</code>的区全都隶属于某个段，而处于<code>FREE</code>、<code>FREE_FRAG</code>以及<code>FULL_FRAG</code>这三种状态的区却
直接隶属于表空间，就像独立团直接听命于军部一样。</p>
</blockquote>
<p>为了方便管理这些区，设计InnoDB 的大叔设计了一个称为XDES Entry 的结构（全称就是Extent Descriptor
Entry），每一个区都对应着一个XDES Entry 结构，这个结构记录了对应的区的一些属性。</p>
<p><img src="image-20220114143818517.png" alt="image-20220114143818517"></p>
<p>XDES Entry <strong>是一个40个字节</strong>的结构，大致分为<strong>4个部分</strong>，各个部分的释义如下：</p>
<ul>
<li>Segment ID （8字节）
每一个段都有一个唯一的编号，用ID表示，此处的Segment ID 字段表示就是该区所在的段。当然前提是该
区已经被分配给某个段了，不然的话该字段的值没啥意义。</li>
<li>List Node （12字节）
这个部分可以将若干个XDES Entry 结构串联成一个链表，如果我们想<strong>定位表空间内的某一个位置的话，只需指定页号以及该位置在指定页号中的页内偏移量即可</strong>。
<ul>
<li>Pre Node Page Number 和Pre Node Offset 的组合就是指向前一个XDES Entry 的指针</li>
<li>Next Node Page Number 和Next Node Offset 的组合就是指向后一个XDES Entry 的指针。</li>
</ul>
</li>
</ul>
<p><img src="image-20220114143926557.png" alt="image-20220114143926557"></p>
<p>也就是说<strong>把一些XDES Entry 结构连成了一个链表</strong></p>
<ul>
<li>
<p>State （4字节）</p>
<p>这个字段表明区的状态。可选的值就是我们前边说过的那4个，分别是： FREE 、FREE_FRAG 、FULL_FRAG
和FSEG</p>
</li>
<li>
<p>Page State Bitmap （16字节）
<strong>这个部分共占用16个字节，也就是128个比特位。我们说一个区默认有64个页，这128个比特位被划分为64</strong>
<strong>个部分，每个部分2个比特位，对应区中的一个页</strong>。比如Page State Bitmap 部分的第1和第2个比特位对应
着区中的第1个页面，第3和第4个比特位对应着区中的第2个页面，依此类推， Page State Bitmap 部分的第
127和128个比特位对应着区中的第64个页面。<strong>这两个比特位的第一个位表示对应的页是否是空闲的，第二个</strong>
<strong>比特位还没有用</strong></p>
</li>
</ul>
<h5 id="xdes-entry链表">XDES Entry链表</h5>
<p>我们已经提出了五花八门的概念，什么区、段、碎片区、附属于段的区、XDES Entry 结构，走远了千万别忘了自己为什么出发，我们把事情搞这么麻烦的初心仅仅是想<strong>提高向表插入数据的效率又不至于数据量少的表浪费空间</strong>。我们知道<strong>向表中插入数据本质上就是向表中各个索引的叶子节点段、非叶子节点段插入数据</strong>，也知道了不同的区有不同的状态，再回到最初的起点，捋一捋向某个段中插入数据的过程</p>
<ul>
<li>
<p>当段中数据较少的时候，首先会查看表空间中是否有状态为FREE_FRAG 的区，也就是找还有空闲空间的碎片区，如果找到了，那么从该区中取一些零碎的页把数据插进去；否则到表空间下申请一个状态为FREE 的区，也就是空闲的区，把该区的状态变为FREE_FRAG ，然后从该新申请的区中取一些零碎的页把数据插进去。之后不同的段使用零碎页的时候都会从该区中取，直到该区中没有空闲空间，然后该区的状态就变成了FULL_FRAG 。</p>
<p>现在的问题是你怎么知道表空间里的哪些区是FREE 的，哪些区的状态FREE_FRAG 的，哪些区是FULL_FRAG 的？要知道表空间的大小是可以不断增大的，当增长到GB级别的时候，区的数量也就上千了，
我们总不能每次都遍历这些区对应的XDES Entry 结构吧？这时候就是XDES Entry 中的List Node 部分发挥奇效的时候了，我们可以通过List Node 中的指针，做这么三件事：</p>
</li>
<li>
<p>把状态为FREE 的区对应的XDES Entry 结构通过List Node 来连接成一个链表，这个链表我们就称之为FREE 链表。</p>
<ul>
<li>把状态为FREE_FRAG 的区对应的XDES Entry 结构通过List Node 来连接成一个链表，这个链表我们就称之为FREE_FRAG 链表。</li>
<li>把状态为FULL_FRAG 的区对应的XDES Entry 结构通过List Node 来连接成一个链表，这个链表我们就称之为FULL_FRAG 链表。
这样每当我们想找一个<strong>FREE_FRAG 状态的区</strong>时，<strong>就直接把FREE_FRAG 链表的头节点拿出来</strong>，从这个节点中取一些零碎的页来插入数据，<strong>当这个节点对应的区用完时，就修改一下这个节点的State 字段的值</strong>，<strong>然后从FREE_FRAG 链表中移到FULL_FRAG 链表</strong>中。同理，<strong>如果FREE_FRAG 链表中一个节点都没有，那</strong>
<strong>么就直接从FREE 链表中取一个节点移动到FREE_FRAG 链表的状态，并修改该节点的STATE 字段值为FREE_FRAG ，然后从这个节点对应的区中获取零碎的页就好了</strong>。</li>
</ul>
</li>
<li>
<p>当段中数据已经占满了32个零散的页后，就直接申请完整的区来插入数据</p>
<p>还是那个问题，我们怎么知道哪些区属于哪个段的呢？再遍历各个XDES Entry 结构？遍历是不可能遍历的，这辈子都不可能遍历的，有链表还遍历个毛线啊。所以我们把状态为<strong>FSEG</strong> 的区对应的XDES Entry 结构都加入到一个链表喽？傻呀，不同的段哪能共用一个区呢？你想把索引a的叶子节点段和索引b的叶子节点段都存储到一个区中么？显然<strong>我们想要每个段都有它独立的链表，所以可以根据段号（也就是Segment ID ）来建立链表</strong>，有多少个段就建多少个链表？好像也有点问题，因为<strong>一个段中可以有好多个区，有的区是完全空闲的，有的区还有一些页面可以用，有的区已经没有空闲页面可以用了</strong>，所以我们有必要继续细分，设计InnoDB 的大叔们为每个段中的区对应的XDES Entry 结构建立了三个链表：</p>
<ul>
<li>FREE 链表：<strong>同一个段中</strong>，所有页面都是空闲的区对应的XDES Entry 结构会被加入到这个链表。注意和直属于表空间的FREE 链表区别开了，<strong>此处的FREE 链表是附属于某个段的</strong>。</li>
<li>NOT_FULL 链表：<strong>同一个段中</strong>，仍有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li>
<li>FULL 链表：<strong>同一个段中</strong>，已经没有空闲空间的区对应的XDES Entry 结构会被加入到这个链表。</li>
</ul>
</li>
</ul>
<p>再次强调一遍，每一个索引都对应两个段，<strong>每个段都会维护上述的3个链表</strong></p>
<pre><code class="language-sql">CREATE TABLE t (
c1 INT NOT NULL AUTO_INCREMENT,
c2 VARCHAR(100),
c3 VARCHAR(100),
PRIMARY KEY (c1),
KEY idx_c2 (c2)
)ENGINE=InnoDB;
</code></pre>
<p>这个表t 共有两个索引，一个聚簇索引，一个二级索引idx_c2 ，所以这个表共有<strong>4个段</strong>，每个段都会维护上述3个链表，总共是12个链表，加上我们上边说过的直属于表空间的<strong>3个链表</strong>，整个独立表空间共需要维护15个链表。所以段在数据量比较大时插入数据的话，会先获取NOT_FULL 链表的头节点，直接把数据插入这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移到FULL 链表中</p>
<h5 id="段的结构">段的结构</h5>
<hr>
<p>我们前边说过，<strong>段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成</strong>。像每个区都有对应的 XDES Entry 来记录这个区中的属性一样，设计 InnoDB 的大叔为每个段都定义了一个 INODE Entry 结构来记录一下段中的属性。大家看一下示意图</p>
<p><img src="image-20220114224256904.png" alt="image-20220114224256904"></p>
<p>它的各个部分释义如下：</p>
<ul>
<li>Segment ID
就是指这个 INODE Entry 结构对应的段的编号（ID）。</li>
<li>NOT_FULL_N_USED
这个字段指的是在 <strong>NOT_FULL 链表中已经使用了多少个页面</strong>。<strong>下次从 NOT_FULL 链表分配空闲页面时可以直接根据这个字段的值定位到</strong>。而不用从链表中的第一个页面开始遍历着寻找空闲页面。</li>
<li>3个 List Base Node
分别为段的 FREE 链表、 NOT_FULL 链表、 FULL 链表定义了 List Base Node ，这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的 List Base Node</li>
<li>Magic Number ：
这个值是用来标记这个 INODE Entry 是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）</li>
<li>Fragment Array Entry
我们前边强调过无数次段是一些零散页面和一些完整的区的集合，每个 Fragment Array Entry <strong>结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号</strong>。</li>
</ul>
<h5 id="各类型页面详细情况">各类型页面详细情况</h5>
<hr>
<p>到现在为止我们已经大概清楚了表空间、段、区、XDES Entry、INODE Entry、各种以 XDES Enty 为节点的链表的基本概念了，但是每个区对应的 <code>XDES Entry 结构</code>到底存储在表空间的什么地方？直属于<code>表空间的 FREE 、 FREE_FRAG 、 FULL_FRAG 链表</code>的基节点到底存储在表空间的什么地方？每个段对应的<code> INODE Entry 结构</code>到底存在表空间的什么地方？我们前边介绍了<strong>每256个连续的区</strong>算是一个组，想解决刚才提出来的这些个疑问还得从每个组开头的一些类型相同的页面说起</p>
<h6 id="fsp_hdr-类型">FSP_HDR 类型</h6>
<p>首先看第一个组的第一个页面，当然也是表空间的第一个页面，页号为 0 。这个页面的类型是 FSP_HDR ，它存储了表空间的一些整体属性以及第一个组内256个区的对应的 XDES Entry 结构，直接看这个类型的页面的示意图</p>
<p><img src="image-20220114234912927.png" alt="image-20220114234912927"></p>
<h3 id="总结-2">总结</h3>
<p>这部分内容比较偏理论，所以自己看的时候也没有特别仔细看，如果以后能遇到可以返回来仔细看看，最后一张图总结表空间：</p>
<p><img src="image-20220114235932635.png" alt="image-20220114235932635"></p>
<h2 id="单表访问方法">单表访问方法</h2>
<p>MySQL Server 有一个称为 <strong>查询优化器</strong> 的模块，一条查询语句进行<strong>语法解析</strong>之后就会被交给查询优化器来进行优化，优化的结果就是生成一个所谓的 <strong>执行计划</strong> ，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的，最后会按照执行计划中的步骤调用<strong>存储引擎提供的方法来真正的执行查询</strong>。先来瞅瞅 MySQL 怎么执行单表查询（就是 FROM 子句后边只有一个表，最简单的那种查询～）。先建表并且建立索引</p>
<pre><code class="language-sql">CREATE TABLE single_table (
id INT NOT NULL AUTO_INCREMENT,
key1 VARCHAR(100),
key2 INT,
key3 VARCHAR(100),
key_part1 VARCHAR(100),
key_part2 VARCHAR(100),
key_part3 VARCHAR(100),
common_field VARCHAR(100),
PRIMARY KEY (id),
KEY idx_key1 (key1),
UNIQUE KEY idx_key2 (key2),
KEY idx_key3 (key3),
KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
</code></pre>
<p>我们为这个 single_table 表建立了1个聚簇索引和4个二级索引，分别是：</p>
<ul>
<li>为 id 列建立的聚簇索引。</li>
<li>为 key1 列建立的 idx_key1 二级索引。</li>
<li>为 key2 列建立的 idx_key2 二级索引，而且该索引是唯一二级索引。</li>
<li>为 key3 列建立的 idx_key3 二级索引。</li>
<li>为 key_part1 、 key_part2 、 key_part3 列建立的 idx_key_part 二级索引，这也是一个联合索引。</li>
</ul>
<h3 id="访问方法access-method的概念">访问方法（access method）的概念</h3>
<hr>
<p>MySQL 中我们平时所写的那些查询语句本质上只是一种声明式的语法，只是告诉 MySQL 我们要获取的数据符合哪些规则，至于 MySQL 背地里是怎么把查询结果搞出来的那是 MySQL 自己的事儿。对于单个表的查询来说，设计MySQL的大叔把查询的执行方式大致分
为下边两种：</p>
<ul>
<li>使用全表扫描进行查询
这种执行方式很好理解，就是把表的每一行记录都扫一遍嘛，把符合搜索条件的记录加入到结果集就完了。</li>
<li>使用索引进行查询
因为直接使用全表扫描的方式执行查询要遍历好多记录，所以代价可能太大了。如果查询语句中的搜索条件可以使用到某个索引，那直接使用索引来执行查询可能会加快查询执行的时间。使用索引来执行查询的方式五花八门，又可以细分为许多种类：
<ul>
<li>针对主键或唯一二级索引的等值查询</li>
<li>针对普通二级索引的等值查询</li>
<li>针对索引列的范围查询</li>
<li>直接扫描整个索引</li>
</ul>
</li>
</ul>
<p><strong>把 MySQL 执行查询语句的方式称之为 访问方法 或者 访问类型</strong>，下边细细道来各种 访问方法 的具体内容。</p>
<h3 id="const">const</h3>
<p>有的时候我们可以通过<strong>主键列</strong>来定位一条记录，比方说这个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE id = 1438;
</code></pre>
<p>MySQL 会直接利用主键值在聚簇索引中定位对应的用户记录,B+ 树叶子节点中的记录是按照索引列排序的，对于聚簇索引来说，它对应的 B+ 树叶子节点中的记录就是按照 id 列排序的。 B+ 树本来就是一个<strong>矮矮的大胖子</strong>，所以这样根据主键值定位一条记录的速度贼快。类似的，我们根<strong>据唯一二级索引列</strong>来定位一条记录的速度也是贼快的，比如下边这个查询</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key2 = 3841;
</code></pre>
<p>通过主键或者唯一二级索引列与常数的等值比较来定位一条记录是像坐火箭一样快的，所以把这种通过<strong>主键</strong>或者<strong>唯一二级索引列</strong>来定位一条记录的访问方法定义为： <strong>const</strong> ，意思是<strong>常数级别</strong>的，代价是可以忽略不计的。不过这种 const 访问方法只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较，这个const 访问方法才有效（这是因为只有该索引中全部列都采用等值比较才可以定位唯一的一条记录）</p>
<p>对于唯一二级索引来说，查询该列为 NULL 值的情况比较特殊，比如这样：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key2 IS NULL;
</code></pre>
<p>因为<strong>唯一二级索引列并不限制 NULL 值的数量</strong>，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用 const 访问方法来执行</p>
<h3 id="ref">ref</h3>
<p>有时候我们对某个普通的二级索引列与常数进行等值比较，比如这样：</p>
<pre><code class="language-java">SELECT * FROM single_table WHERE key1 = 'abc';
</code></pre>
<p>对于这个查询，我们当然可以选择全表扫描来逐一对比搜索条件是否满足要求，我们也可以先使用二级索引找到对应记录的 id 值，然后再回表到聚簇索引中查找完整的用户记录。由于普通二级索引并不限制索引列值的唯一性，所以可能找到多条对应的记录，也就是说使用<strong>二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数</strong>。如果匹配的记录较少，则回表的代价还是比较低的，所以 MySQL 可能选择使用索引而不是全表扫描的方式来执行查询。设计 MySQL 的大叔就<strong>把这种搜索条件为二级索引列与常数等值比较，采用二级索引来执行查询的访问方法称为： ref</strong> 。我们看一下采用 ref 访问方法执行查询的图示：</p>
<p><img src="image-20220116184621350.png" alt="image-20220116184621350"></p>
<p>需要注意下边两种情况：</p>
<ul>
<li>
<p>二级索引列值为 NULL 的情况
不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 NULL 值的数量并不限制，所以我们采用key IS NULL 这种形式的搜索条件最多只能使用 ref 的访问方法，而不是 const 的访问方法。</p>
</li>
<li>
<p>对于某个包含多个索引列的二级索引(聚合索引)来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 ref的访问方法，比方说下边这几个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key_part1 = 'god like';
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';
SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary' AND key_part3 = 'penta kill';
</code></pre>
<p>但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为 ref 了，比方说这样：</p>
</li>
</ul>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 &gt; 'legendary';
</code></pre>
<h3 id="ref_or_null">ref_or_null</h3>
<p>有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出来，就像下边这个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
</code></pre>
<p>当使用二级索引而不是全表扫描的方式执行该查询时，这种类型的查询使用的访问方法就称为ref_or_null ，这个 ref_or_null 访问方法的执行过程如下：</p>
<h3 id="range">range</h3>
<p>之前介绍的几种访问方法都是在对索引列与某一个常数进行等值比较的时候才可能使用到（ ref_or_null 比较奇特，还计算了值为 NULL 的情况），但是有时候我们面对的搜索条件更复杂，比如下边这个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 &gt;= 38 AND key2 &lt;= 79);
</code></pre>
<p>如果采用 二级索引 + 回表 的方式来执行的话，那么此时的搜索条件就不只是要求索引列与常数的等值匹配了，而是<strong>索引列需要匹配某个或某些范围的值</strong>,把这种利用<strong>索引</strong>(可以是聚簇索引，也可以是二级索引)进行<strong>范围匹配</strong>的访问方法称之为： range</p>
<h3 id="index">index</h3>
<pre><code class="language-sql">SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';
</code></pre>
<p>由于 key_part2 并不是联合索引 idx_key_part <strong>最左索引列</strong>，所以我们无法使用 ref 或者 range 访问方法来执行这个语句。但是这个查询符合下边这两个条件：</p>
<ul>
<li>它的查询列表只有3个列： key_part1 , key_part2 , key_part3 ，而索引 <strong>idx_key_part 又包含这三个列</strong>。</li>
<li><strong>搜索条件中只有 key_part2 列。这个列也包含在索引 idx_key_part 中</strong>。</li>
</ul>
<p>也就是说我们可以直接通过遍历 <strong>idx_key_part 索引的叶子节点</strong>的记录来比较key_part2 = &lsquo;abc&rsquo; 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行<strong>回表操作</strong>，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多，把这种采用遍历二级索引记录的执行方式称之为index</p>
<h3 id="all">all</h3>
<p>最直接的查询执行方式全表扫描，对于 InnoDB 表来说也就是直接扫描<strong>聚簇索引</strong>，把这种使用全表扫描执行查询的方式称之为： all 。</p>
<h3 id="注意事项">注意事项</h3>
<h4 id="二级索引--回表">二级索引 + 回表</h4>
<hr>
<p><strong>一般情况下只能利用单个二级索引执行查询</strong>，比方说下边的这个查询</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 = 'abc' AND key2 &gt; 1000;
key1 和 key2都建有索引
</code></pre>
<p>优化器一般会根据 single_table 表的<strong>统计数据</strong>来判断到底<strong>使用哪个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询</strong>。然后将从该二级索引中查询到的结果经过<strong>回表</strong>得到完整的用户记录后再根据其余的 <strong>WHERE 条件过滤记录</strong>。
一般来说，等值查找比范围查找需要扫描的行数更少（也就是 ref 的访问方法一般比 range 好，但这也不总是一定的，也可能采用 ref 访问方法的那个索引列的值为特定值的行数特别多），所以这里假设优化器决定使用idx_key1 索引进行查询，那么整个查询过程可以分为两个步骤：</p>
<ul>
<li>步骤1：使用二级索引定位记录的阶段，也就是根据条件 key1 = &lsquo;abc&rsquo; 从 idx_key1 索引代表的 B+ 树中找到对应的二级索引记录。</li>
<li>步骤2：回表阶段，也就是根据上一步骤中找到的记录的主键值进行 回表 操作，也就是到聚簇索引中找到对应的完整的用户记录，再根据条件 key2 &gt; 1000 到完整的用户记录继续过滤。将最终符合过滤条件的记录返回给用户。</li>
</ul>
<p>为什么呢？因为二级索引的节点中的记录只包含<strong>索引列和主键</strong>，所以在步骤1中使用
idx_key1 索引进行查询时只会用到与 key1 列有关的搜索条件，其余条件，比如 key2 &gt; 1000 这个条件在步骤1中是用不到的，只<strong>有在步骤2完成回表操作后才能继续针对完整的用户记录中继续过滤</strong></p>
<h4 id="明确range访问方法使用的范围区间">明确range访问方法使用的范围区间</h4>
<p>其实对于 B+ 树索引来说，只要索引列和常数使用 = 、 &lt;=&gt; 、 IN 、 NOT IN 、 IS NULL 、 IS NOT NULL 、&gt;、 &lt; 、 &gt;= 、 &lt;= 、 BETWEEN 、 != （不等于也可以写成 &lt;&gt; ）或者 LIKE 操作符连接起来，就可以产生一个所谓的 区间 。</p>
<blockquote>
<p>IN操作符的效果和若干个等值匹配操作符<code>=</code>之间用<code>OR</code>连接起来是一样的，也就是说会产生多个单点区间，比如下边这两个语句的效果是一样的：
SELECT * FROM single_table WHERE key2 IN (1438, 6328);
SELECT * FROM single_table WHERE key2 = 1438 OR key2 = 6328;</p>
</blockquote>
<p>当我们想使用 range 访问方法来执行一个查询语句时，重点就是找出该查询可用的索引以及这些索引对应的范围区间。下边分两种情况看一下怎么从由 AND 或 OR 组成的复杂搜索条件中提取出正确的范围区间。</p>
<h5 id="所有搜索条件都可以使用某个索引的情况">所有搜索条件都可以使用某个索引的情况</h5>
<p>每个搜索条件都可以使用到某个索引,那肯定是可以用索引进行范围查询的，例如</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key2 &gt; 100 AND key2 &gt; 200;
SELECT * FROM single_table WHERE key2 &gt; 100 OR key2 &gt; 200;
</code></pre>
<h5 id="有的搜索条件无法使用索引的情况">有的搜索条件无法使用索引的情况</h5>
<pre><code>SELECT * FROM single_table WHERE key2 &gt; 100 AND common_field = 'abc';
</code></pre>
<p>请注意，这个查询语句中能利用的索引只有 idx_key2 一个，而 idx_key2 这个二级索引的记录中又不包含common_field 这个字段，所以在使用二级索引 idx_key2 定位记录的阶段用不到 common_field = &lsquo;abc&rsquo; 这个条件，这个条件是在回表获取了完整的用户记录后才使用的，而 范围区间 是为了到索引中取记录中提出的概念，所以在确定 范围区间 的时候不需要考虑 common_field = &lsquo;abc&rsquo; 这个条件，我们在为某个索引确定范围区间的时候只需要把用不到相关索引的搜索条件替换为 TRUE 就好了</p>
<pre><code class="language-sql">我们把上边的查询中用不到 idx_key2 的搜索条件替换后就是这样：
SELECT * FROM single_table WHERE key2 &gt; 100 AND TRUE;
化简之后就是这样：
SELECT * FROM single_table WHERE key2 &gt; 100;
</code></pre>
<p>也就是说最上边那个查询使用 idx_key2 的范围区间就是： (100, +∞) 。</p>
<p>再来看一下使用 OR 的情况：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key2 &gt; 100 OR common_field = 'abc';
同理，我们把使用不到 idx_key2 索引的搜索条件替换为 TRUE ：
SELECT * FROM single_table WHERE key2 &gt; 100 OR TRUE;
接着化简：
SELECT * FROM single_table WHERE TRUE;
</code></pre>
<p>这也就说说明如果我们强制使用 idx_key2 执行查询的话，对应的范围区间就是 (-∞, +∞) ，也就是需要将<strong>全部二级索引的记录进行回表，这个代价肯定比直接全表扫描都大了</strong>。也就是说一<strong>个使用到索引的搜索条件</strong>和<strong>没有使用该索引的搜索条件</strong>使用 <strong>OR 连接</strong>起来后是无法使用该索引的。</p>
<h4 id="索引合并">索引合并</h4>
<p><strong>MySQL 在一般情况下执行一个查询时最多只会用到单个二级索引</strong>，但不是还有特殊情况么，在这些特殊情况下也可能在一个查询中使用到多个二级索引，设计 MySQL 的大叔把这种<strong>使用到多个索引来完成一次查询的执行方法</strong>称之为： <strong>index merge</strong> ，具体的索引合并算法有下边三种</p>
<h5 id="intersection合并">Intersection合并</h5>
<hr>
<p>Intersection 翻译过来的意思是 <strong>交集</strong> 。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
</code></pre>
<p>假设这个查询使用 Intersection 合并的方式执行的话，那这个过程就是这样的：</p>
<ul>
<li>从 idx_key1 二级索引对应的 B+ 树中取出 key1 = &lsquo;a&rsquo; 的相关记录。</li>
<li>从 idx_key3 二级索引对应的 B+ 树中取出 key3 = &lsquo;b&rsquo; 的相关记录。</li>
<li>二级索引的记录都是由 索引列 + 主键 构成的，所以我们可以计算出这两个结果集中 id 值的交集。</li>
<li>按照上一步生成的 id 值列表进行回表操作，也就是从聚簇索引中把指定 id 值的完整用户记录取出来，返回给用户。</li>
</ul>
<p>为啥不直接使用 idx_key1 或者 idx_key3 只根据某个搜索条件去读取一个二级索引，然后回表后再过滤另外一个搜索条件呢？这里要分析一下两种查询执行方式之间需要的成本代价。
只读取一个二级索引的成本：</p>
<ul>
<li>按照某个搜索条件读取一个二级索引</li>
<li>根据从该二级索引得到的主键值进行回表操作，然后再过滤其他的搜索条件</li>
</ul>
<p>读取多个二级索引之后取交集成本：</p>
<ul>
<li>按照不同的搜索条件分别读取不同的二级索引</li>
<li>将从多个二级索引得到的主键值取交集，然后进行回表操作</li>
</ul>
<p>虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是<code>顺序I/O</code> ，而回表操作是 <code>随机I/O</code> ，<strong>所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少</strong>，当节省的因为 回表 而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。</p>
<p>MySQL 在某些特定的情况下才可能会使用到 Intersection 索引合并：</p>
<ul>
<li>
<p>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。
比方说下边这个查询可能用到 idx_key1 和 idx_key_part 这两个二级索引进行 Intersection 索引合并的操作：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';
</code></pre>
<p>而下边这两个查询就不能进行 Intersection 索引合并：</p>
<pre><code class="language-sql">因为对 key1 进行了范围匹配
SELECT * FROM single_table WHERE key1 &gt; 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';
因为联合索引 idx_key_part 中的 key_part2 列并没有出现在搜索条件中
SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a';
</code></pre>
</li>
<li>
<p>情况二：主键列可以是范围匹配
比方说下边这个查询可能用到主键和 idx_key1 进行 Intersection 索引合并的操作：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE id &gt; 100 AND key1 = 'a';
</code></pre>
<p>对于 InnoDB 的二级索引来说，记录先是按照索引列进行排序，如果该二级索引是一个联合索引，那么会按照联合索引中的各个列依次排序。而二级索引的用户记录是由 索引列 + 主键 构成的，二级索引列的值相同的记录可能会有好多条，这些索引列的值相同的记录又是按照主键 的值进行排序的。所以重点来了，之所以<strong>在二级索引列都是等值匹配</strong>的情况下才可能使用 Intersection 索引合并，是因为<strong>只有在这种情况下根据二级索引查询出的结果集是按照主键值排序的</strong>。</p>
</li>
</ul>
<p>假设某个查询使用Intersection 索引合并的方式从 idx_key1 和 idx_key2 这两个二级索引中获取到的主键值分别是：</p>
<ul>
<li>从 idx_key1 中获取到已经排好序的主键值：1、3、5</li>
<li>从 idx_key2 中获取到已经排好序的主键值：2、3、4</li>
</ul>
<p>那么求交集的过程就是这样：逐个取出这两个结果集中最小的主键值，如果两个值相等，则加入最后的交集结果中，否则丢弃当前较小的主键值，再取该丢弃的主键值所在结果集的后一个主键值来比较，直到某个结果集中的主键值用完了，过程如下：</p>
<ul>
<li>先取出这两个结果集中较小的主键值做比较，因为 1 &lt; 2 ，所以把 idx_key1 的结果集的主键值 1 丢弃，取出后边的 3 来比较。</li>
<li>因为 3 &gt; 2 ，所以把 idx_key2 的结果集的主键值 2 丢弃，取出后边的 3 来比较。</li>
<li>因为 3 = 3 ，所以把 3 加入到最后的交集结果中，继续两个结果集后边的主键值来比较。</li>
<li>后边的主键值也不相等，所以最后的交集结果中只包含主键值 3 。</li>
</ul>
<p>这个过程其实可快了，时间复杂度是 O(n) ，但是<strong>如果从各个二级索引中查询出的结果集并不是按照主键排序的话</strong>，那就要先把结果集中的主键值排序完再来做上边的那个过程，就比较耗时了</p>
<p>另外，不仅是多个二级索引之间可以采用 Intersection 索引合并，索引合并也可以有聚簇索引参加，也就是我们上边写的 情况二 ：在搜索条件中有主键的范围匹配的情况下也可以使用 Intersection 索引合并索引合并。</p>
<p>当然，上边说的 情况一 和 情况二 只是发生 Intersection 索引合并的<strong>必要条件</strong>，不是<strong>充分条件</strong>。也就是说即使情况一、情况二成立，也不一定发生 Intersection 索引合并，这得看优化器的心情。<strong>优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过 Intersection 索引合并后需要回表的记录数大大减少时才会使用 Intersection 索引合并</strong></p>
<h5 id="union合并">Union合并</h5>
<hr>
<p><strong>Union 是并集的意思，适用于使用不同索引的搜索条件之间使用 OR 连接起来的情况</strong>。与 Intersection 索引合并类似，MySQL 在某些特定的情况下才可能会使用到 Union 索引合并</p>
<ul>
<li>
<p>情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况。
比方说下边这个查询可能用到 idx_key1 和 idx_key_part 这两个二级索引进行 Union 索引合并的操作：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 = 'a' OR ( key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c');
</code></pre>
<p>而下边这两个查询就不能进行 Union 索引合并：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 &gt; 'a' OR (key_part1 = 'a' AND key_part2 = 'b'
AND key_part3 = 'c');
SELECT * FROM single_table WHERE key1 = 'a' OR key_part1 = 'a';
</code></pre>
<p>第一个查询是因为对 key1 进行了范围匹配，第二个查询是因为联合索引idx_key_part 中的 key_part2 列并没有出现在搜索条件中，所以这两个查询不能进行 Union 索引合并。</p>
</li>
<li>
<p>情况二：主键列可以是范围匹配</p>
</li>
<li>
<p>情况三：使用 Intersection 索引合并的搜索条件
这种情况其实也挺好理解，就是搜索条件的某些部分使用 Intersection 索引合并的方式得到的主键集合和其他方式得到的主键集合取交集，比方说这个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');
</code></pre>
<p>优化器可能采用这样的方式来执行这个查询：</p>
<ul>
<li>先按照搜索条件 key1 = &lsquo;a&rsquo; AND key3 = &lsquo;b&rsquo; 从索引 idx_key1 和 idx_key3 中使用 Intersection 索引合并的方式得到一个主键集合。</li>
<li>再按照搜索条件 key_part1 = &lsquo;a&rsquo; AND key_part2 = &lsquo;b&rsquo; AND key_part3 = &lsquo;c&rsquo; 从联合索引idx_key_part 中得到另一个主键集合。</li>
<li>采用 Union 索引合并的方式把上述两个主键集合取并集，然后进行回表操作，将结果返回给用户。</li>
</ul>
</li>
</ul>
<p>当然，查询条件符合了这些情况也不一定就会采用 Union 索引合并，也得看优化器的心情。<strong>优化器只有在单独根据搜索条件从某个二级索引中获取的记录数比较少，通过 Union 索引合并后进行访问的代价比全表扫描更小时才会使用 Union 索引合并</strong>。</p>
<h5 id="sort-union合并">Sort-Union合并</h5>
<p>Union 索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到 Union 索引合并：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 &lt; 'a' OR key3 &gt; 'z'
</code></pre>
<p>这是因为根据 key1 &lt; &lsquo;a&rsquo; 从 idx_key1 索引中获取的二级索引记录的主键值不是排好序的，根据 key3 &gt;&lsquo;z&rsquo; 从 idx_key3 索引中获取的二级索引记录的主键值也不是排好序的，但是 key1 &lt; &lsquo;a&rsquo; 和 key3 &gt; &lsquo;z&rsquo; 这两个条件又特别让我们动心，所以我们可以这样：</p>
<ul>
<li>先根据 key1 &lt; &lsquo;a&rsquo; 条件从 idx_key1 二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>再根据 key3 &gt; &lsquo;z&rsquo; 条件从 idx_key3 二级索引总获取记录，并按照记录的主键值进行排序</li>
<li>因为上述的两个二级索引主键值都是排好序的，剩下的操作和 Union 索引合并方式就一样了。</li>
</ul>
<p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照 Union 索引合并方式执行的方式称之为 Sort-Union 索引合并，很显然，这种 Sort-Union 索引合并比单纯的 Union 索引合并多了一步对二级索引记录的主键值排序的过程。</p>
<h5 id="联合索引替代intersection索引合并">联合索引替代Intersection索引合并</h5>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
</code></pre>
<p>这个查询之所以可能使用 Intersection 索引合并的方式执行，还不是因为 idx_key1 和 idx_key3 是<strong>两个单独的 B+ 树索引</strong>，你要是把这两个列搞一个联合索引，那直接使用这个联合索引就把事情搞定了。因此如果出Intersection索引合并最好采用联合索引优化。</p>
<h3 id="多表连接">多表连接</h3>
<h4 id="嵌套循环连接nested-loop-join">嵌套循环连接（Nested-Loop Join）</h4>
<hr>
<p>对于两表连接来说，<strong>驱动表只会被访问一遍</strong>，但被驱动表却要被访问到好多遍，具体访问几遍取决于对驱动表执行单表查询后的结果集中的记录条数。对于内连接来说，选取哪个表为驱动表都没关系，而外连接的驱动表是固定的，也就是说左（外）连接的驱动表就是左边的那个表，右（外）连接的驱动表就是右边的那个表</p>
<p>t1 表和t2 表执行内连接查询的大致过程如下：</p>
<ul>
<li>步骤1：<strong>选取驱动表，使用与驱动表相关的过滤条件</strong>，选取代价最低的单表访问方法来执行对驱动表的单表
查询。</li>
<li>步骤2：对上一步骤中查询驱动表得到的结果集中每一条记录，都分别到被驱动表中查找匹配的记录。</li>
</ul>
<p>如果有3个表进行连接的话，那么步骤2 中得到的结果集就像是新的驱动表，然后第三个表就成为了被驱动表，
重复上边过程，也就是步骤2 中得到的结果集中的每一条记录都需要到t3 表中找一找有没有匹配的记录，用伪
代码表示一下这个过程就是这样：</p>
<pre><code class="language-java">for each row in t1 { #此处表示遍历满足对t1单表查询结果集中的每一条记录
    for each row in t2 { #此处表示对于某条t1表的记录来说，遍历满足对t2单表查询结果集中的
    每一条记录
        for each row in t3 { #此处表示对于某条t1和t2表的记录组合来说，对t3表进行单表查询
        	if row satisfies join conditions, send to client
        }
    }
}
</code></pre>
<p>这个过程就像是一个嵌套的循环，所以这种<strong>驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于</strong>
<strong>对驱动表执行单表查询后的结果集中的记录条数</strong>的连接执行方式称之为<code>嵌套循环连接</code>（ Nested-Loop Join ），
这是最简单，也是最笨拙的一种连接查询算法</p>
<h4 id="使用索引加快连接速度">使用索引加快连接速度</h4>
<hr>
<p>我们知道在嵌套循环连接的步骤2 中可能需要<strong>访问多次被驱动表</strong>，如果访问被驱动表的方式都是<strong>全表扫描</strong>的话，妈呀，那得要扫描好多次呀～～～ 回顾一下最开始介绍的t1 表和t2 表进行内连接的例子：</p>
<pre><code class="language-sql">SELECT * FROM t1, t2 WHERE t1.m1 &gt; 1 AND t1.m1 = t2.m2 AND t2.n2 &lt; 'd';
</code></pre>
<p>我们使用的其实是嵌套循环连接算法执行的连接查询，再把上边那个查询执行过程表拉下来给大家看一下：</p>
<p><img src="image-20220117110318912.png" alt="image-20220117110318912">查询驱动表t1 后的结果集中有两条记录， 嵌套循环连接算法需要对被驱动表查询2次：</p>
<ul>
<li>当t1.m1 = 2 时，去查询一遍t2 表，对t2 表的查询语句相当于：
SELECT * FROM t2 WHERE t2.m2 = 2 AND t2.n2 &lt; &rsquo;d';</li>
<li>当t1.m1 = 3 时，再去查询一遍t2 表，此时对t2 表的查询语句相当于：
SELECT * FROM t2 WHERE t2.m2 = 3 AND t2.n2 &lt; &rsquo;d';</li>
</ul>
<p>可以看到，原来的t1.m1 = t2.m2 这个涉及两个表的过滤条件在针对t2 表做查询时关于t1 表的条件就已经确
定了，<strong>所以我们只需要单单优化对t2 表的查询了</strong>，上述两个对t2 表的查询语句中利用到的列是m2 和n2 列，
我们可以：</p>
<ul>
<li>在m2 列上建立索引，因为对m2 列的条件是等值查找，比如t2.m2 = 2 、t2.m2 = 3 等，所以可能使用到
<strong>ref</strong> 的访问方法，假设使用ref 的访问方法去执行对t2 表的查询的话，需要回表之后再判断t2.n2 &lt; d 这
个条件是否成立。这里有一个比较特殊的情况，就是假设m2 列是t2 表的<strong>主键或者唯一二级索引列</strong>，那么使用t2.m2 = 常数值这样的条件从t2 表中查找记录的过程的代价就是常数级别的。我们知道在单表中使用主键值或者唯一二级索引列的值进行等值查找的方式称之为<strong>const</strong> ，而设计MySQL 的大叔<strong>把在连接查询中对被驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称之为： eq_ref</strong> 。</li>
<li>在n2 列上建立索引，涉及到的条件是t2.n2 &lt; &rsquo;d' ，可能用到range 的访问方法，假设使用range 的访问
方法对t2 表的查询的话，需要回表之后再判断在m2 列上的条件是否成立。</li>
<li>m2 和n2 列上都存在索引的话，那么就需要从这两个里边儿挑一个代价更低的去执行对t2 表的查询。当
然，<strong>建立了索引不一定使用索引，只有在二级索引 + 回表的代价比全表扫描的代价更低时才会使用索引</strong></li>
</ul>
<h4 id="基于块的嵌套循环连接block-nested-loop-join">基于块的嵌套循环连接（Block Nested-Loop Join）</h4>
<p>扫描一个表的过程其实是先把这个表从磁盘上加载到内存中，然后从内存中比较匹配条件是否满足。现实生活中
的表可不像t1 、t2 这种只有3条记录，成千上万条记录都是少的，几百万、几千万甚至几亿条记录的表到处都
是。<strong>内存里可能并不能完全存放的下表中所有的记录，所以在扫描表前边记录的时候后边的记录可能还在磁盘</strong>
<strong>上，等扫描到后边记录的时候可能内存不足，所以需要把前边的记录从内存中释放掉</strong>。我们前边又说过，采用嵌
套循环连接算法的两表连接过程中，<strong>被驱动表可是要被访问好多次的，如果这个被驱动表中的数据特别多而且不</strong>
<strong>能使用索引进行访问</strong>，那就相当于要从磁盘上读好几次这个表，这个I/O 代价就非常大了，所以我们得想办法：
<strong>尽量减少访问被驱动表的次数</strong>。</p>
<p>当被驱动表中的数据非常多时，每次访问被驱动表，<strong>被驱动表的记录会被加载到内存中</strong>，在内存中的<strong>每一条记录</strong>
只会和驱动表结果集的<strong>一条记录</strong>做匹配，之后就会被从内存中清除掉。然后再从驱动表结果集中拿出另一条记
录，再一次把被驱动表的记录加载到内存中一遍，周而复始，<strong>驱动表结果集中有多少条记录，就得把被驱动表从</strong>
<strong>磁盘上加载到内存中多少次</strong>。</p>
<p>所以我们可不可以在把被驱动表的记录加载到内存的时候，<strong>一次性和多条驱动表中的记录做匹配</strong>，这样就可以大大减少重复从磁盘上加载被驱动表的代价了。所以设计MySQL 的大叔提出了一个 join buffer 的概念， <strong>join buffer 就是执行连接查询前申请的一块固定大小的内存</strong>，<strong>先把若干条驱动表结果集中的记录装在这个 join buffer 中</strong>，然后开始扫描被驱动表，<strong>每一条被驱动表的记录一次性和join buffer 中的多条驱动表记录做匹配</strong>，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的I/O 代价</p>
<p><img src="image-20220117111912869.png" alt="image-20220117111912869"></p>
<p>最好的情况是join buffer 足够大，能容纳驱动表结果集中的所有记录，这样只需要访问一次被驱动表就可以完
成连接操作了。设计MySQL 的大叔<strong>把这种加入了join buffer 的嵌套循环连接算法称之为基于块的嵌套连接</strong>
<strong>（Block Nested-Loop Join）算法。</strong></p>
<p>这个join buffer 的大小是可以通过启动参数或者系统变量join_buffer_size 进行配置，默认大小为262144字
节（也就是<strong>256KB</strong> ），最小可以设置为128字节，对于优化被驱动表的查询来说，最好是为<strong>被驱动表</strong>加上效率高的索引，另外需要注意的是，<strong>驱动表的记录并不是所有列都会被放到join buffer 中，只有查询列表中的列和过滤条件中的列才会被放到join buffer 中</strong>，所以再次提醒我们，最好不要把* 作为查询列表，只需要把我们关心的列放到查询列表就好了</p>
<h2 id="mysql基于成本的优化">MySQL基于成本的优化</h2>
<p>MySQL 执行一个查询可以有不同的执行方案，它会选择其中成本最低那种方案去真正的执行查询。不过我们之前对成本的描述是非常模糊的，其实在MySQL 中一条查询语句的执行成本是由下边这两个方面组成的：</p>
<ul>
<li>I/O 成本
我们的表经常使用的MyISAM 、InnoDB 存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的
记录时，需要先把数据或者索引加载到内存中然后再操作。这个<strong>从磁盘到内存这个加载的过程损耗的时间称</strong>
<strong>之为I/O 成本</strong>。</li>
<li>CPU 成本
读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为CPU 成本。</li>
</ul>
<p>对于InnoDB 存储引擎来说，页是磁盘和内存之间交互的基本单位，设计MySQL 的大叔规定读取一个页面花费的
成本默认是1.0 ，读取以及检测一条记录是否符合搜索条件的成本默认是0.2 。1.0 、0.2 这些数字称之为成
本常数。</p>
<h3 id="单表查询的成本">单表查询的成本</h3>
<h4 id="基于成本的优化步骤">基于成本的优化步骤</h4>
<p>在一条单表查询语句真正执行之前， MySQL 的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出
成本最低的方案，这个成本最低的方案就是所谓的执行计划，之后才会调用存储引擎提供的接口真正的执行查询，这个过程总结一下就是这样：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引</li>
<li>计算全表扫描的代价</li>
<li>计算使用不同索引执行查询的代价</li>
<li>对比各种执行方案的代价，找出成本最低的那一个</li>
</ol>
<p>我们以这个实例来分析一下这些步骤</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE
key1 IN ('a', 'b', 'c') AND
key2 &gt; 10 AND key2 &lt; 1000 AND
key3 &gt; key2 AND
key_part1 LIKE '%hello%' AND
common_field = '123';
</code></pre>
<h5 id="根据搜索条件找出所有可能使用的索引">根据搜索条件，找出所有可能使用的索引</h5>
<p>我们分析一下上边查询中涉及到的几个搜索条件：</p>
<ul>
<li>key1 IN (&lsquo;a&rsquo;, &lsquo;b&rsquo;, &lsquo;c&rsquo;) ，这个搜索条件可以使用二级索引idx_key1 。</li>
<li>key2 &gt; 10 AND key2 &lt; 1000 ，这个搜索条件可以使用二级索引idx_key2 。</li>
<li>key3 &gt; key2 ，这个搜索条件的索引列由于没有和常数比较，所以并不能使用到索引。</li>
<li>key_part1 LIKE &lsquo;%hello%&rsquo; ， key_part1 通过LIKE 操作符和以通配符开头的字符串做比较，不可以适用
索引。</li>
<li>common_field = &lsquo;123&rsquo; ，由于该列上压根儿没有索引，所以不会用到索引。</li>
</ul>
<p>综上所述，上边的查询语句可能用到的索引，也就是possible keys 只有idx_key1 和idx_key2 。</p>
<h5 id="计算全表扫描的代价">计算全表扫描的代价</h5>
<p>对于InnoDB 存储引擎来说，全表扫描的意思就是把<strong>聚簇索引中的记录都依次和给定的搜索条件做一下比较</strong>，把
符合搜索条件的记录加入到结果集，所以需要将聚簇索引对应的页面加载到内存中，然后再检测记录是否符合搜
索条件。由于查询成本= I/O 成本+ CPU 成本，所以计算全表扫描的代价需要两个信息：</p>
<ul>
<li>聚簇索引占用的页面数</li>
<li>该表中的记录数</li>
</ul>
<p>这两个信息从哪来呢？设计MySQL 的大叔为每个表维护了一系列的统计信息，使用SHOW TABLE STATUS 语句来查看表的统计信息,例如</p>
<pre><code class="language-sql">SHOW TABLE STATUS LIKE 't_bls_order_detail';
</code></pre>
<p><img src="image-20220117204350662.png" alt="image-20220117204350662"></p>
<p>这些属性都基本上可以认识。其中</p>
<ul>
<li>
<p>Rows
本选项表示表中的记录条数。对于使用MyISAM 存储引擎的表来说，该值是准确的，对于使用InnoDB 存储引
擎的表来说，该值是一个估计值。</p>
</li>
<li>
<p>Data_length
本选项表示表占用的存储空间<strong>字节数</strong>。使用MyISAM 存储引擎的表来说，该值就是数据文件的大小，对于使
用InnoDB 存储引擎的表来说，该值就相当于<strong>聚簇索引</strong>占用的存储空间大小，也就是说可以这样计算该值的
大小：</p>
<p>Data_length = 聚簇索引的页面数量 x 每个页面的大小</p>
</li>
</ul>
<p>我们的single_table 使用默认16KB 的页面大小，而上边查询结果显示Data_length 的值是1589248 ，所以我们可以反向来推导出聚簇索引的页面数量：
聚簇索引的页面数量 = 1589248 ÷ 16 ÷ 1024 = 97</p>
<p>我们现在已经得到了聚簇索引占用的页面数量以及该表记录数的估计值，所以就可以计算全表扫描成本了</p>
<ul>
<li>I/O 成本
97 x 1.0 + 1.1 = 98.1
97 指的是聚簇索引占用的页面数， 1.0 指的是加载一个页面的成本常数，后边的1.1 是一个微调值，我们
不用在意。</li>
<li>CPU 成本：
9693 x 0.2 + 1.0 = 1939.6
9693 指的是统计数据中表的记录数，对于InnoDB 存储引擎来说是一个估计值， 0.2 指的是访问一条记录
所需的成本常数，后边的1.0 是一个微调值，我们不用在意。</li>
<li>总成本：
98.1 + 1939.6 = 2037.7</li>
</ul>
<p>综上所述，对于single_table 的全表扫描所需的总成本就是2037.7 。</p>
<h5 id="计算使用不同索引执行查询的代价">计算使用不同索引执行查询的代价</h5>
<p>从第1步分析我们得到，上述查询可能使用到idx_key1 和idx_key2 这两个索引，我们需要分别分析单独使用这
些索引执行查询的成本，最后还要分析是否可能使用到索引合并。这里需要提一点的是， <strong>MySQL 查询优化器先分</strong>
<strong>析使用唯一二级索引的成本，再分析使用普通索引的成本</strong>，所以我们也先分析idx_key2 的成本，然后再看使用
idx_key1 的成本。</p>
<p>idx_key2 对应的搜索条件是： key2 &gt; 10 AND key2 &lt; 1000 ，也就是说对应的范围区间就是： (10, 1000) ，对于使用二级索引 + 回表方式的查询，设计MySQL 的大叔计算这种查询的成本依赖两个方面的数据：</p>
<ul>
<li>
<p>范围区间数量
不论某个范围区间的二级索引到底占用了多少页面，查询优化器粗暴的认为读取索引的一个范围区间的I/O
成本和读取一个页面是相同的。本例中使用idx_key2 的范围区间只有一个： (10, 1000) ，所以相当于访问
这个范围区间的二级索引付出的I/O 成本就是：
1 x 1.0 = 1.0</p>
</li>
<li>
<p>需要回表的记录数
优化器需要计算二级索引的某个范围区间到底包含多少条记录，对于本例来说就是要计算idx_key2 在(10,</p>
<p>1000）这个范围区间中包含多少二级索引记录，计算过程是这样的：</p>
<ul>
<li>步骤1：先根据key2 &gt; 10 这个条件访问一下idx_key2 对应的B+ 树索引，找到满足key2 &gt; 10 这个条
件的第一条记录，我们把这条记录称之为区间最左记录。我们前头说过在B+ 数树中定位一条记录的过
程是贼快的，是常数级别的，所以这个过程的性能消耗是可以忽略不计的。</li>
<li>步骤2：然后再根据key2 &lt; 1000 这个条件继续从idx_key2 对应的B+ 树索引中找出第一条满足这
个条件的记录，我们把这条记录称之为区间最右记录，这个过程的性能消耗也可以忽略不计的。</li>
<li>步骤3：如果区间最左记录和区间最右记录相隔不太远（在MySQL 5.7.21 这个版本里，只要相
隔不大于10个页面即可），那就可以精确统计出满足key2 &gt; 10 AND key2 &lt; 1000 条件的二级索引
记录条数。否则只沿着区间最左记录向右读10个页面，计算平均每个页面中包含多少记录，然后
用这个平均值乘以区间最左记录和区间最右记录之间的页面数量就可以了。那么问题又来了，怎
么估计区间最左记录和区间最右记录之间有多少个页面呢？解决这个问题还得回到B+ 树索引的
结构中来：</li>
</ul>
</li>
</ul>
<p><img src="image-20220117205128844.png" alt="image-20220117205128844"></p>
<p>如图，我们假设区间最左记录在页b 中， 区间最右记录在页c 中，那么我们想计算区间最左记
录和区间最右记录之间的页面数量就相当于计算页b 和页c 之间有多少页面，而每一条目录项
记录都对应一个数据页，所以计算页b 和页c 之间有多少页面就相当于<strong>计算它们父节点（也就是</strong>
<strong>页a）中对应的目录项记录之间隔着几条记录</strong></p>
<p>知道了如何统计二级索引某个范围区间的记录数之后，就需要回到现实问题中来，根据上述算法测得
idx_key2 在区间(10, 1000) 之间大约有95 条记录。读取这95 条二级索引记录需要付出的CPU 成本
就是：
95 x 0.2 + 0.01 = 19.01
其中95 是需要读取的二级索引记录条数， 0.2 是读取一条记录成本常数， 0.01 是微调</p>
<p>在通过二级索引获取到记录之后，还需要干两件事儿：</p>
<ul>
<li>
<p>根据这些记录里的主键值到聚簇索引中做回表操作
这里需要大家使劲儿睁大自己滴溜溜的大眼睛仔细瞧，设计MySQL 的大叔评估回表操作的I/O 成本
依旧很豪放，他们认为每次回表操作都相当于访问一个页面，也就是说二级索引范围区间有多少记
录，就需要进行多少次回表操作，也就是需要进行多少次页面I/O 。我们上边统计了使用idx_key2 二级索引执行查询时，预计有95 条二级索引记录需要进行回表操作，所以回表操作带来
的I/O 成本就是：
95 x 1.0 = 95.0
其中95 是预计的二级索引记录数， 1.0 是一个页面的I/O 成本常数。</p>
</li>
<li>
<p>回表操作后得到的完整用户记录，然后再检测其他搜索条件是否成立
回表操作的本质就是通过二级索引记录的主键值到聚簇索引中找到完整的用户记录，然后再检测除
key2 &gt; 10 AND key2 &lt; 1000 这个搜索条件以外的搜索条件是否成立。因为我们通过范围区间获取
到二级索引记录共95 条，也就对应着聚簇索引中95 条完整的用户记录，读取并检测这些完整的用
户记录是否符合其余的搜索条件的CPU 成本如下：</p>
<p>95 x 0.2 = 19.0</p>
</li>
</ul>
<p>所以本例中使用idx_key2 执行查询的成本就如下所示：</p>
<ul>
<li>I/O 成本：
1.0 + 95 x 1.0 = 96.0 (范围区间的数量 + 预估的二级索引记录条数)</li>
<li>CPU 成本：
95 x 0.2 + 0.01 + 95 x 0.2 = 38.01 （读取二级索引记录的成本 + 读取并检测回表后聚簇索
引记录的成本）</li>
<li>综上所述，使用idx_key2 执行查询的总成本就是：
96.0 + 38.01 = 134.01</li>
</ul>
<p>使用idx_key1执行的成本就不分析了，其实成本分析我们一般都用不到，只是想了解过程而已。</p>
<h4 id="基于索引统计数据的成本计算">基于索引统计数据的成本计算</h4>
<p>有时候使用索引执行查询时会有许多单点区间，比如使用IN 语句就很容易产生非常多的单点区间，比如下边这
个查询：</p>
<pre><code class="language-sql">SELECT * FROM single_table WHERE key1 IN ('aa1', 'aa2', 'aa3', ... , 'zzz');
</code></pre>
<p>很显然，这个查询可能使用到的索引就是idx_key1 ，由于这个索引并不是唯一二级索引，所以并不能确定一个
单点区间对应的二级索引记录的条数有多少，需要我们去计算。计算方式我们上边已经介绍过了，就是先获取索
引对应的B+ 树的区间最左记录和区间最右记录，然后再计算这两条记录之间有多少记录（记录条数少的时候
可以做到精确计算，多的时候只能估算）。设计MySQL 的大叔<strong>把这种通过直接访问索引对应的B+ 树来计算某个</strong>
<strong>范围区间对应的索引记录条数的方式称之为index dive</strong> 。</p>
<p>有零星几个单点区间的话，使用index dive 的方式去计算这些单点区间对应的记录数也不是什么问题，可是你
架不住有的孩子憋足了劲往IN 语句里塞东西呀，我就见过有的同学写的IN 语句里有20000个参数的🤣🤣，这
就意味着MySQL 的查询优化器为了计算这些单点区间对应的索引记录条数，要进行20000次index dive 操作，
这性能损耗可就大了，搞不好计算这些单点区间对应的索引记录条数的成本比直接全表扫描的成本都大了。设计
MySQL 的大叔们多聪明啊，他们当然考虑到了这种情况，所以提供了一个系统变量</p>
<pre><code class="language-sql">SHOW VARIABLES LIKE '%dive%';
</code></pre>
<blockquote>
<p>大家需要注意一下，在MySQL 5.7.3以及之前的版本中，eq_range_index_dive_limit的默认值为10，之
后的版本默认值为200。所以如果大家采用的是5.7.3以及之前的版本的话，很容易采用索引统计数据而
不是index dive的方式来计算查询成本。当你的查询中使用到了IN查询，但是却实际没有用到索引，就
应该考虑一下是不是由于 eq_range_index_dive_limit 值太小导致的</p>
</blockquote>
<p>也就是说如果我们的IN 语句中的参数个数小于这个值的话，将使用index dive 的方式计算各个单点区间对应的
记录条数，如果大于或等于200个的话，可就不能使用index dive 了，要使用所谓的索引统计数据来进行估算</p>
<p>像会为每个表维护一份统计数据一样， MySQL 也会为表中的每一个索引维护一份统计数据，查看某个表中索引的
统计数据可以使用SHOW INDEX FROM 表名的语法，比如：</p>
<pre><code class="language-sql">show index from t_bls_order_detail;
</code></pre>
<p><img src="image-20220117210301332.png" alt="image-20220117210301332"></p>
<p>Non_unique 索引列的值是否是唯一的，聚簇索引和唯一二级索引的该列值为0 ，普通二级索引该列值为1 。
Key_name 索引的名称。
Seq_in_index 索引列在索引中的位置，从1开始计数。比如对于联合索引idx_key_part ，来说， key_part1 、key_part2和key_part3 对应的位置分别是1、2、3。
Column_name 索引列的名称。
Collation 索引列中的值是按照何种排序方式存放的，值为A 时代表升序存放，为NULL 时代表降序存放。
Cardinality 索引列中不重复值的数量。后边我们会重点看这个属性的。
Sub_part 对于存储字符串或者字节串的列来说，有时候我们只想对这些串的前n 个字符或字节建立索引，这个属性表示的就是那个n 值。如果对完整的列建立索引的话，该属性的值就是NULL 。
Packed 索引列如何被压缩， NULL 值表示未被压缩。这个属性我们暂时不了解，可以先忽略掉。
Null 该索引列是否允许存储NULL 值。
Index_type 使用索引的类型，我们最常见的就是BTREE ，其实也就是B+ 树索引。
Comment 索引列注释信息。
Index_comment 索引注释信息。</p>
<p>我们现在最在意的是Cardinality 属性， Cardinality 直译过来就是基数的意思，表示索引列中不重复值的个数。比如对于一个一万行记录的表来说，某个索引列的Cardinality 属性是10000 ，那意味着该列中没有重复的值，如果Cardinality 属性是1 的话，就意味着该列的值全部是重复的。不过需要注意的是，对于InnoDB存储引擎来说，<strong>使用SHOW INDEX语句展示出来的某个索引列的Cardinality属性是一个估计值，并不是精确的</strong>。</p>
<p>当IN 语句中的参数个数大于或等于系统变量eq_range_index_dive_limit 的值的话，就不会使用
index dive 的方式计算各个单点区间对应的索引记录条数，而是使用索引统计数据，这里所指的索引统计数据
指的是这两个值：</p>
<ul>
<li>使用SHOW TABLE STATUS 展示出的Rows 值，也就是一个表中有多少条记录。</li>
<li>使用SHOW INDEX 语句展示出的Cardinality 属性。
结合上一个Rows 统计数据，我们可以针对索引列，计算出平均一个值重复多少次。
一个值的重复次数 ≈ Rows ÷ Cardinality</li>
</ul>
<p>此时再看上边那条查询语句：
SELECT * FROM single_table WHERE key1 IN (&lsquo;aa1&rsquo;, &lsquo;aa2&rsquo;, &lsquo;aa3&rsquo;, &hellip; , &lsquo;zzz&rsquo;);
假设IN 语句中有20000个参数的话，就直接使用统计数据来估算这些参数需要单点区间对应的记录条数了，每
个参数大约对应10 条记录，所以总共需要回表的记录数就是：
20000 x 10 = 200000</p>
<h3 id="连接查询的成本">连接查询的成本</h3>
<h4 id="condition-filtering介绍">Condition filtering介绍</h4>
<p>我们前边说过， MySQL 中连接查询采用的是<strong>嵌套循环连接算法</strong>，驱动表会被访问一次，被驱动表可能会被访问多
次，所以对于两表连接查询来说，它的查询成本由下边两个部分构成：</p>
<ul>
<li>单次查询驱动表的成本</li>
<li>多次查询被驱动表的成本（具体查询多少次取决于对驱动表查询的结果集中有多少条记录）</li>
</ul>
<p><strong>我们把对驱动表进行查询后得到的记录条数称之为驱动表的扇出</strong>（英文名： fanout ）。<strong>很显然驱动表的扇出值</strong>
<strong>越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低</strong>。</p>
<h4 id="两表连接的成本分析">两表连接的成本分析</h4>
<p>连接查询的成本计算公式是这样的：</p>
<blockquote>
<p>连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次 访问被驱动表的成本</p>
</blockquote>
<p>对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：
分别为驱动表和被驱动表选择成本最低的访问方法。
可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：</p>
<ul>
<li>不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。</li>
<li>然后分别为驱动表和被驱动表选择成本最低的访问方法。</li>
</ul>
<p>比如对于下边这个查询来说：</p>
<pre><code class="language-sql">SELECT * FROM single_table AS s1 INNER JOIN single_table2 AS s2
ON s1.key1 = s2.common_field
WHERE s1.key2 &gt; 10 AND s1.key2 &lt; 1000 AND
s2.key2 &gt; 1000 AND s2.key2 &lt; 2000;
</code></pre>
<p>可以选择的连接顺序有两种：</p>
<ul>
<li>s1 连接s2 ，也就是s1 作为驱动表， s2 作为被驱动表。</li>
<li>s2 连接s1 ，也就是s2 作为驱动表， s1 作为被驱动表。</li>
</ul>
<p>查询优化器需要分别考虑这两种情况下的最优查询成本，然后选取那个成本更低的连接顺序以及该连接顺序下各
个表的最优访问方法作为最终的查询计划。我们分别来看一下）：</p>
<ul>
<li>
<p>使用s1 作为驱动表的情况</p>
<ul>
<li>分析对于驱动表的成本最低的执行方案
首先看一下涉及s1 表单表的搜索条件有哪些：
s1.key2 &gt; 10 AND s1.key2 &lt; 1000
所以这个查询可能使用到idx_key2 索引，从全表扫描和使用idx_key2 这两个方案中选出成本最低
的那个，这个过程我们上边都唠叨过了，很显然使用idx_key2 执行查询的成本更低些。
然后分析对于被驱动表的成本最低的执行方案
此时涉及被驱动表idx_key2 的搜索条件就是：
s2.common_field = 常数（这是因为对驱动表s1 结果集中的每一条记录，都需要进行一次被驱动
表s2 的访问，此时那些涉及两表的条件现在相当于只涉及被驱动表s2 了。）
s2.key2 &gt; 1000 AND s2.key2 &lt; 2000
很显然，第一个条件由于common_field 没有用到索引，所以并没有什么卵用，此时访问
single_table2 表时可用的方案也是全表扫描和使用idx_key2 两种，很显然使用idx_key2 的成
本更小。
所以此时使用single_table 作为驱动表时的总成本就是（暂时不考虑使用join buffer 对成本的影
响）：
使用idx_key2访问s1的成本 + s1的扇出 × 使用idx_key2访问s2的成本</li>
</ul>
</li>
<li>
<p>使用s2 作为驱动表的情况
分析对于驱动表的成本最低的执行方案
首先看一下涉及s2 表单表的搜索条件有哪些：
s2.key2 &gt; 10 AND s2.key2 &lt; 1000
所以这个查询可能使用到idx_key2 索引，从全表扫描和使用idx_key2 这两个方案中选出成本最低的那个，这个过程我们上边都唠叨过了，很显然使用idx_key2 执行查询的成本更低些。然后分析对于被驱动表的成本最低的执行方案此时涉及被驱动表idx_key2 的搜索条件就是：
s1.key1 = 常数
s1.key2 &gt; 1000 AND s1.key2 &lt; 2000
这时就很有趣了，使用idx_key1 可以进行ref 方式的访问，使用idx_key2 可以使用range 方式的访问。这是优化器需要从全表扫描、使用idx_key1 、使用idx_key2 这几个方案里选出一个成本最低的方案。这里有个问题啊，因为idx_key2 的范围区间是确定的： (10, 1000) ，怎么计算使用idx_key2 的成本我们上边已经说过了，可是在没有真正执行查询前， s1.key1 = 常数中的常数值我们是不知道的，怎么衡量使用idx_key1 执行查询的成本呢？其实很简单，直接使用索引统计数据就好了（就是索引列平均一个值重复多少次）。一般情况下， ref 的访问方式要比range 成本最低，这里假设使用idx_key1 进行对s2 的访问。所以此时使用single_table 作为驱动表时的总成本就是：
使用idx_key2访问s2的成本 + s2的扇出 × 使用idx_key1访问s1的成本</p>
</li>
</ul>
<p>最后优化器会比较这两种方式的最优访问成本，选取那个成本更低的连接顺序去真正的执行查询。从上边的计算
过程也可以看出来，连接查询成本占大头的其实是驱动表扇出数 x 单次访问被驱动表的成本，所以我们的优化重点其实是下边这两个部分：</p>
<ul>
<li><strong>尽量减少驱动表的扇出</strong></li>
<li><strong>对被驱动表的访问成本尽量低</strong></li>
</ul>
<p>这一点对于我们实际书写连接查询语句时十分有用，我们需要尽量<strong>在被驱动表的连接列上建立索引</strong>，这样就
可以使用ref 访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者
唯一二级索引列，这样就可以把访问被驱动表的成本降到更低了。</p>
<p>如果<strong>某个索引列中NULL 值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多</strong>，所以倾向于<strong>不使用索引进行访问</strong>,最好不在索引列中存放NULL值</p>
<h4 id="生产问题分析">生产问题分析</h4>
<hr>
<p>这是一个统计的需求，其中t_bls_order_detail有一百多万条数据，t_bls_order_flow这个表次之，其他两个表数据量较少，当时写完这个sql，一上线就慢sql了</p>
<pre><code class="language-sql">select
       s.bar_name                                                              as barName,
       sum(o.number)                                                           as saleNum,
       sum(o.trans_amt)                                                        as saleAmt,
       sum(IFNULL(o.refunded_num, 0) * (o.PRICE + o.PARTS_PRICE)) as refundAmt
from t_bls_order_detail o
         inner join t_bls_order_flow f on o.order_id = f.order_id and
                                          (f.status = '1' or (f.status = '3' and f.refund_total_amt = f.trans_amt))
         inner join t_bls_product_bar p on o.shop_id = p.shop_id and o.product_id = p.product_id
         inner join t_bls_sales_bar s on p.shop_id = s.shop_id and p.bar_id = s.bar_id
WHERE o.status = '1'
  and o.SHOP_ID = '1333584333856333855'
  and o.create_time &gt;= '2020-12-30 00:00:00'
  and o.create_time &lt;= '2021-12-30 23:59:59'
group by s.bar_name
HAVING saleNum &gt; 0
order by saleAmt desc;
</code></pre>
<h2 id="mysql基于规则的优化">MySQL基于规则的优化</h2>
<h3 id="条件化简">条件化简</h3>
<ul>
<li>
<p>常量传递（constant_propagation）</p>
<p>有时候某个表达式是某个列和某个常量做等值匹配，比如这样：
a = 5
当这个表达式和其他涉及列a 的表达式使用AND 连接起来时，可以将其他表达式中的a 的值替换为5 比如样：
a = 5 AND b &gt; a
就可以被转换为：
a = 5 AND b &gt; 5</p>
</li>
<li>
<p>等值传递（equality_propagation）</p>
<p>有时候多个列之间存在等值匹配的关系，比如这样：
a = b and b = c and c = 5
这个表达式可以被简化为：
a = 5 and b = 5 and c = 5</p>
</li>
<li>
<p>表达式计算</p>
<p>在查询开始执行之前，如果表达式中只包含常量的话，它的值会被先计算出来，比如这个：
a = 5 + 1
因为5 + 1 这个表达式只包含常量，所以就会被化简成：
a = 6
但是这里需要注意的是，如果某个列并不是以单独的形式作为表达式的操作数时，比如出现在函数中出现在某
个更复杂表达式中，就像这样：
ABS(a) &gt; 5 或者：-a &lt; -8
优化器是不会尝试对这些表达式进行化简的。因为只有搜索条件中<strong>索引列和常数</strong>使用<strong>某些运算符连接起来</strong>才可能使用到索引，所以如果可以的话，最好<strong>让索引列以单独的形式出现在表达式中</strong>。</p>
</li>
</ul>
<h3 id="外连接消除">外连接消除</h3>
<hr>
<p>内连接的驱动表和被驱动表的位置可以相互转换，而左（外）连接和右（外）连接的驱动表和被驱动表是固定的。这就导致<strong>内连接可能通过优化表的连接顺序来降低整体的查询成本</strong>，而外连接却无法优化表的连接顺序</p>
<p>外连接和内连接的本质区别就是：<strong>对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃</strong></p>
<p>那么只要在搜索条件中指定<strong>关于被驱动表相关列的值不为NULL</strong> ，那么外连接中在被驱动表中找不到符合ON 子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：<strong>外连接和内连接也就没有什么区别了！</strong></p>
<pre><code class="language-sql">这两个sql本质上是一样的，WHERE 子句中指定了被驱动表t2 的m2 列等于2 ，也就相当于间接的指定了m2 列不为
NULL 值，
SELECT * FROM t1 LEFT JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
SELECT * FROM t1 INNER JOIN t2 ON t1.m1 = t2.m2 WHERE t2.m2 = 2;
</code></pre>
<p>把这种在外连接查询中，指定的<strong>WHERE 子句中包含被驱动表中的列不为NULL 值</strong>的条件称之为<code>空值拒绝</code>（英文名： reject-NULL ）。<strong>在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换</strong>。这种转换带来的好处就是<strong>查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询</strong>。</p>
<h3 id="子查询优化">子查询优化</h3>
<p><strong>由子查询结果集组成的表称之为派生表</strong></p>
<h4 id="按返回的结果集区分子查询">按返回的结果集区分子查询</h4>
<p>因为子查询本身也算是一个查询，所以可以按照它们返回的不同结果集类型而把这些子查询分为不同的类型</p>
<ul>
<li>
<p>标量子查询
那些只返回一个单一值的子查询称之为标量子查询，比如这样：</p>
<pre><code class="language-sql">SELECT (SELECT m1 FROM t1 LIMIT 1);
SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);
</code></pre>
<p>这两个查询语句中的子查询都返回一个单一的值，也就是一个<strong>标量</strong>。这些标量子查询可以作为一个单一值
或者表达式的一部分出现在查询语句的各个地方。</p>
</li>
<li>
<p>行子查询
顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：</p>
<pre><code class="language-sql">SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);
其中的(SELECT m2, n2 FROM t2 LIMIT 1) 就是一个行子查询
</code></pre>
</li>
<li>
<p>列子查询
列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标
量子查询了）。比如这样：</p>
<pre><code class="language-sql">SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
其中的(SELECT m2 FROM t2) 就是一个列子查询，
</code></pre>
</li>
<li>
<p>表子查询
顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：</p>
<pre><code>SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
其中的(SELECT m2, n2 FROM t2) 就是一个表子查询
</code></pre>
</li>
</ul>
<h4 id="按与外层查询关系来区分子查询">按与外层查询关系来区分子查询</h4>
<ul>
<li>不相关子查询
如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查
询。我们前边介绍的那些子查询全部都可以看作不相关子查询。</li>
<li>相关子查询
<strong>如果子查询的执行需要依赖于外层查询的值</strong>，我们就可以把这个子查询称之为相关子查询。比如：
SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);
例子中的子查询是(SELECT m2 FROM t2 WHERE n1 = n2) ，可是这个查询中有一个搜索条件是n1 = n2 也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个<strong>相关子查询</strong>。</li>
</ul>
<h4 id="子查询在mysql中是怎么执行的">子查询在MySQL中是怎么执行的</h4>
<h5 id="标量子查询行子查询的执行方式">标量子查询、行子查询的执行方式</h5>
<p>我们经常在下边两个场景中使用到标量子查询或者行子查询：</p>
<ul>
<li>SELECT 子句中，我们前边说过的在查询列表中的子查询必须是标量子查询。</li>
<li>子查询使用= 、&gt; 、&lt; 、&gt;= 、&lt;= 、&lt;&gt; 、!= 、&lt;=&gt; 等操作符和某个操作数组成一个布尔表达式，这样的子查询必须是标量子查询或者行子查询。</li>
</ul>
<p>对于上述两种场景中的不相关标量子查询或者行子查询来说，它们的执行方式是简单的，比方说下边这个查询语句：</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 = (SELECT common_field FROM s2 WHERE key3 = 'a' LIMIT 1);
</code></pre>
<p>它的执行方式：</p>
<ul>
<li>先单独执行(SELECT common_field FROM s2 WHERE key3 = &lsquo;a&rsquo; LIMIT 1) 这个子查询。</li>
<li>然后在将上一步子查询得到的结果当作外层查询的参数再执行外层查询SELECT * FROM s1 WHERE key1 =</li>
</ul>
<p>也就是说，<strong>对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子</strong>
<strong>查询，就当作两个单表查询就好了</strong>。</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);
</code></pre>
<p>它的执行方式就是这样的：</p>
<ul>
<li>先从外层查询中获取一条记录，本例中也就是先从s1 表中获取一条记录。</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从s1 表中获取的那条记录中找
出s1.key3 列的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询WHERE 子句的条件是否成立，如果成立，就把外层查询的那条记
录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
<h5 id="in子查询优化">IN子查询优化</h5>
<h6 id="物化表">物化表</h6>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
</code></pre>
<p>我们最开始的感觉就是这种不相关的IN 子查询和不相关的标量子查询或者行子查询是一样一样的，都是把外层查询和子查询当作两个独立的单表查询来对待,但是如果单独执行子查询后的结果集太多的话，就会导致这
些问题：</p>
<ul>
<li>结果集太多，可能内存中都放不下～</li>
<li>对于外层查询来说，如果子查询的结果集太多，那就意味着IN 子句中的参数特别多，这就导致：
<ul>
<li>无法有效的使用索引，只能对外层查询进行全表扫描。</li>
<li>在对外层查询执行全表扫描时，由于IN 子句中的参数太多，这会导致检测一条记录是否符合和IN 子句
中的参数匹配花费的时间太长。
比如说IN 子句中的参数只有两个：
SELECT * FROM tbl_name WHERE column IN (a, b);
这样相当于需要对tbl_name 表中的每条记录判断一下它的column 列是否符合column = a OR column
= b 。在IN 子句中的参数比较少时这并不是什么问题，如果IN 子句中的参数比较多时，比如这样：
SELECT * FROM tbl_name WHERE column IN (a, b, c &hellip;, &hellip;);
那么这样每条记录需要判断一下它的column 列是否符合column = a OR column = b OR column = c
OR &hellip; ，这样性能耗费可就多了。</li>
</ul>
</li>
</ul>
<p>于是乎设计MySQL 的大叔想了一个招：<strong>不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写</strong>
<strong>入一个临时表里</strong>。写入临时表的过程是这样的：</p>
<ul>
<li>该临时表的列就是子查询结果集中的列。</li>
<li>写入临时表的记录会被去重。
我们说IN 语句是判断某个操作数在不在某个集合中，集合中的值重不重复对整个IN 语句的结果并没有啥子
关系，所以我们在将结果集写入临时表时对记录进行去重可以让临时表变得更小，更省地方～</li>
</ul>
<blockquote>
<p>小贴士：
临时表如何对记录进行去重？这不是小意思嘛，临时表也是个表，只要为表中记录的所有列建立
主键或者唯一索引就好了嘛～</p>
</blockquote>
<ul>
<li>一般情况下子查询结果集不会大的离谱，所以会为<strong>它建立基于内存的使用Memory 存储引擎的临时表</strong>，而且
会为该表建立<strong>哈希索引</strong>。</li>
</ul>
<blockquote>
<p>IN语句的本质就是判断某个操作数在不在某个集合里，如果集合中的数据建立了哈希索引，那么这个匹配的过程就是超级快的。所谓的哈希索引其实就是哈希表，key为hash值即为通过特定算法由指定列数据计算出来，value为存储地址即为所在数据行存储在硬盘上的地址（也有可能是其他存储地址，其实MEMORY会将hash表导入内存）</p>
<p>具体参考https://www.jianshu.com/p/732a16af1f8d</p>
<p>如果子查询的结果集非常大，超过了系统变量tmp_table_size 或者max_heap_table_size ，临时表会转而
使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为B+ 树索引。</p>
</blockquote>
<p>把这个将<strong>子查询结果集中的记录保存到临时表的过程称之为物化</strong>（英文名：Materialize ）。为了方便起见，我们就把那个存储子查询结果集的临时表称之为物化表。正因为物化表中的记录都建立了<strong>索引</strong>（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过<strong>索引</strong>执行IN 语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了<strong>子查询语句的性能</strong>。</p>
<h6 id="物化表转连接">物化表转连接</h6>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
</code></pre>
<p>当我们把子查询进行物化之后，假设子查询物化表的名称为materialized_table ，该物化表存储的子查询结果
集的列为m_val,那么这个查询其实可以从下边两种角度来看待：</p>
<ul>
<li>从表s1 的角度来看待，整个查询的意思其实是：对于s1 表中的每条记录来说，如果该记录的key1 列的值
在子查询对应的物化表中，则该记录会被加入最终的结果集。画个图表示一下就是这样：</li>
</ul>
<p><img src="image-20220120174949195.png" alt="image-20220120174949195"></p>
<ul>
<li>从子查询物化表的角度来看待，整个查询的意思其实是：对于子查询物化表的每个值来说，如果能在s1 表
中找到对应的key1 列的值与该值相等的记录，那么就把这些记录加入到最终的结果集。画个图表示一下就
是这样：</li>
</ul>
<p><img src="image-20220120175010364.png" alt="image-20220120175010364"></p>
<p>其实上边的查询就相当于表s1 和子查询物化表materialized_table 进行<strong>内连接</strong>：</p>
<pre><code>SELECT s1.* FROM s1 INNER JOIN materialized_table ON key1 = m_val;
</code></pre>
<p>转化成内连接之后就有意思了，查询优化器可以评估<strong>不同连接顺序需要的成本是多少，选取成本最低的那种查询</strong>
<strong>方式执行查询</strong></p>
<ul>
<li>如果使用s1 表作为驱动表的话，总查询成本由下边几个部分组成：
<ul>
<li>物化子查询时需要的成本</li>
<li>扫描s1 表时的成本</li>
<li>s1表中的记录数量 × 通过m_val = xxx 对materialized_table 表进行单表访问的成本（我们前边说过物化表中的记录是不重复的，并且为物化表中的列建立了索引，所以这个步骤显然是非常快的）。</li>
</ul>
</li>
<li>如果使用materialized_table 表作为驱动表的话，总查询成本由下边几个部分组成：</li>
<li>物化子查询时需要的成本</li>
<li>扫描物化表时的成本</li>
<li>物化表中的记录数量 × 通过key1 = xxx 对s1 表进行单表访问的成本。</li>
</ul>
<h6 id="将子查询转换为semi-join">将子查询转换为semi-join</h6>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a');
</code></pre>
<p>对于s1 表的某条记录来说，由于我们只关心s2 表中是否存在记录满足s1.key1 = s2.common_field 这个条件，而不关心具体有多少条记录与之匹配，我们上边所说的IN 子查询和两表连接之间并不完全等价。但是将子查询转换为连接又真的可以充分发挥优化器的作用，所以设计MySQL 的大叔在这里提出了一个新概念 &mdash; <strong>半连接</strong>（英文名： semi-join ）。将s1 表和s2 表进行半连接的意思就是：<strong>对于s1 表的某条记录来说，我们只关心在s2 表中是否存在与之匹配的记录是否存在，而不关心具体有多少条记录与之匹配，最终的结果集中只保留s1 表的记录</strong>。为了让大家有更直观的感受，我们<strong>假设</strong>MySQL内部是这么改写上边的子查询的：</p>
<pre><code class="language-sql">SELECT s1.* FROM s1 SEMI JOIN s2 ON s1.key1 = s2.common_field WHERE key3 = 'a';
</code></pre>
<p>对于<strong>某些</strong>使用IN 语句的相关子查询可以使用半连接来执行查询，<strong>由于相关子查询并不是一个独立的查询，所以不能转换为物化表来执行查询</strong></p>
<h6 id="semi-join的适用条件">semi-join的适用条件</h6>
<p>当然，并不是所有包含IN 子查询的查询语句都可以转换为semi-join ，只有形如这样的查询才可以被转换为</p>
<pre><code class="language-sql">SELECT ... FROM outer_tables
WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...
或者这样的形式也可以：
SELECT ... FROM outer_tables
WHERE (oe1, oe2, ...) IN (SELECT ie1, ie2, ... FROM inner_tables ...) AND ...
</code></pre>
<p>用文字总结一下，只有符合下边这些条件的子查询才可以被转换为semi-join ：</p>
<ul>
<li>该子查询必须是和IN 语句组成的布尔表达式，并且在外层查询的WHERE 或者ON 子句中出现。</li>
<li>外层查询也可以有其他的搜索条件，只不过和IN 子查询的搜索条件必须使用AND 连接起来。</li>
<li>该子查询必须是一个单一的查询，不能是由若干查询由UNION 连接起来的形式。</li>
<li>该子查询不能包含GROUP BY 或者HAVING 语句或者聚集函数。</li>
</ul>
<h6 id="不适用于semi-join的情况">不适用于semi-join的情况</h6>
<ul>
<li>
<p>外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用OR 连接起来</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a') OR key2 &gt; 100;
</code></pre>
</li>
<li>
<p>使用NOT IN 而不是IN 的情况</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 NOT IN (SELECT common_field FROM s2 WHERE key3 = 'a')
</code></pre>
</li>
<li>
<p>在SELECT 子句中的IN子查询的情况</p>
<pre><code class="language-sql">SELECT key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a') FROM s1 ;
</code></pre>
</li>
<li>
<p>子查询中包含GROUP BY 、HAVING 或者聚集函数的情况</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key2 IN (SELECT COUNT(*) FROM s2 GROUP BY key1);
</code></pre>
</li>
<li>
<p>子查询中包含UNION 的情况</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT common_field FROM s2 WHERE key3 = 'a'UNION
SELECT common_field FROM s2 WHERE key3 = 'b');
</code></pre>
</li>
<li>
<p>IN 子查询尝试专为EXISTS 子查询</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 where s1.common_field = s2.common_field) OR key2 &gt; 1000;
SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 where s1.common_field =s2.common_field AND s2.key3 = s1.key1) OR key2 &gt; 1000;
</code></pre>
<p><strong>转为EXISTS 子查询时便可以使用到s2 表的idx_key3 索引了</strong></p>
</li>
</ul>
<h6 id="小结一下">小结一下</h6>
<ul>
<li>如果IN 子查询符合转换为semi-join 的条件，查询优化器会优先把该子查询为semi-join ，然后再考虑下边5种执行半连接的策略中哪个成本最低：
<ul>
<li>Table pullout</li>
<li>DuplicateWeedout</li>
<li>LooseScan</li>
<li>Materialization</li>
<li>FirstMatch</li>
</ul>
</li>
<li>选择成本最低的那种执行策略来执行子查询。
如果IN 子查询不符合转换为semi-join 的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：
<ul>
<li>先将子查询物化之后再执行查询</li>
<li>执行IN to EXISTS 转换。</li>
</ul>
</li>
</ul>
<h5 id="not-exists子查询的执行">[NOT] EXISTS子查询的执行</h5>
<p>如果[NOT] EXISTS 子查询是<strong>不相关子查询</strong>，可以先执行子查询，得出该[NOT] EXISTS 子查询的结果是TRUE 还
是FALSE ，并重写原先的查询语句，比如对这个查询来说：</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 WHERE key1 = 'a') OR key2 &gt; 100;
假设该EXISTS子查询的结果为TRUE
SELECT * FROM s1 WHERE TRUE OR key2 &gt; 100;
SELECT * FROM s1 WHERE TRUE;
</code></pre>
<p>对于<strong>相关</strong>的[NOT] EXISTS 子查询来说，比如这个查询：</p>
<pre><code>SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 WHERE s1.common_field = s2.common_field);
</code></pre>
<p>很不幸，这个查询只能按照我们年少时的那种执行相关子查询的方式来执行。</p>
<ul>
<li>先从外层查询中获取一条记录，本例中也就是先从s1 表中获取一条记录。</li>
<li>然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，本例中就是从s1 表中获取的那条记录中找出s1.key2 列的值，然后执行子查询。</li>
<li>最后根据子查询的查询结果来检测外层查询WHERE 子句的条件是否成立，如果成立，就把外层查询的那
条记录加入到结果集，否则就丢弃。</li>
<li>再次执行第一步，获取第二条外层查询中的记录，依次类推～</li>
</ul>
<h5 id="派生表的优化">派生表的优化</h5>
<p>过把子查询放在外层查询的FROM 子句后，那么这个子查询的结果相当于一个<strong>派生表</strong></p>
<pre><code class="language-sql">SELECT * FROM (
-- 这个子查询就是派生表
SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = 'a'
) AS derived_s1 WHERE d_key3 = 'a';
</code></pre>
<p>对于含有派生表的查询， MySQL 提供了两种执行策略：</p>
<ul>
<li>
<p>最容易想到的就是把派生表物化。
我们可以将派生表的结果集写到一个内部的临时表中，然后就把这个物化表当作普通表一样参与查询。当
然，在对派生表进行物化时，设计MySQL 的大叔使用了一种称为延迟物化的策略，<strong>也就是在查询中真正使</strong>
<strong>用到派生表时才回去尝试物化派生表</strong>，而不是还没开始执行查询呢就把派生表物化掉。比方说对于下边这个
含有派生表的查询来说：</p>
<pre><code class="language-sql">SELECT * FROM (
SELECT * FROM s1 WHERE key1 = 'a'
) AS derived_s1 INNER JOIN s2 ON derived_s1.key1 = s2.key1 WHERE s2.key2 = 1;
</code></pre>
<p>如果采用物化派生表的方式来执行这个查询的话，那么执行时<strong>首先会到s1 表中找出满足s1.key2 = 1 的记录</strong>，如果压根儿找不到，说明参与连接的s1 表记录就是空的，所以整个查询的结果集就是空的，所以也就没有必要去物化查询中的派生表了</p>
</li>
<li>
<p>将派生表和外层的表合并，也就是将查询重写为没有派生表的形式</p>
<p>我们来看这个贼简单的包含派生表的查询：</p>
<pre><code class="language-sql">SELECT * FROM (SELECT * FROM s1 WHERE key1 = 'a') AS derived_s1;
等价于
SELECT * FROM s1 WHERE key1 = 'a';
</code></pre>
<p>对于一些稍微复杂的包含派生表的语句，比如我们上边提到的那个：</p>
<pre><code class="language-sql">SELECT * FROM (SELECT * FROM s1 WHERE key1 = 'a') AS derived_s1 INNER JOIN s2 ON derived_s1.key1 = s2.key1 WHERE s2.key2 = 1;
我们可以将派生表与外层查询的表合并，然后将派生表中的搜索条件放到外层查询的搜索条件中：
SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.key1 = 'a' AND s2.key2 = 1;
</code></pre>
</li>
</ul>
<p>这样通过将外层查询和派生表合并的方式成功的消除了派生表，也就意味着我们没必要再付出创建和访问临时表的成本了。可是并不是所有带有派生表的查询都能被成功的和外层查询合并，当派生表中有这些语句就不可以和外层查询合并：</p>
<ul>
<li>聚集函数，比如MAX()、MIN()、SUM()啥的</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>LIMIT</li>
<li>UNION 或者 UNION ALL</li>
<li>派生表对应的子查询的SELECT 子句中含有另一个子查询</li>
</ul>
<p>这一章读下来并没有感觉学到很多东西</p>
<h2 id="explain详解">Explain详解</h2>
<p>一条查询语句在经过<strong>MySQL 查询优化器</strong>的各种基于成本和规则的优化会后生成一个所谓的<strong>执行计划</strong>，这个执行
计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行
查询等等。使用EXPLAIN 语句来帮助我们查看某个查询语句的具体执行计划</p>
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">id</td>
<td style="text-align:center">在一个大的查询语句中每个SELECT 关键字都对应一个唯一的id</td>
</tr>
<tr>
<td style="text-align:center">select_type</td>
<td style="text-align:center">SELECT 关键字对应的那个查询的类型</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">表名</td>
</tr>
<tr>
<td style="text-align:center">partitions</td>
<td style="text-align:center">匹配的分区信息</td>
</tr>
<tr>
<td style="text-align:center">type</td>
<td style="text-align:center">针对<strong>单表</strong>的访问方法</td>
</tr>
<tr>
<td style="text-align:center">possible_keys</td>
<td style="text-align:center">可能用到的索引</td>
</tr>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">实际上使用的索引</td>
</tr>
<tr>
<td style="text-align:center">key_len</td>
<td style="text-align:center">实际使用到的索引长度</td>
</tr>
<tr>
<td style="text-align:center">ref</td>
<td style="text-align:center">当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td style="text-align:center">rows</td>
<td style="text-align:center">预估的需要读取的记录条数</td>
</tr>
<tr>
<td style="text-align:center">filtered</td>
<td style="text-align:center">某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td style="text-align:center">Extra</td>
<td style="text-align:center">一些额外的信息</td>
</tr>
</tbody>
</table>
<h3 id="id">id</h3>
<hr>
<p>查询语句中每出现一个SELECT 关键字，设计MySQL 的大叔就会为它分配一个唯一的id 值。</p>
<p>对于连接查询来说，<strong>一个SELECT 关键字后边的FROM 子句中可以跟随多个表</strong>，所以在连接查询的执行计划中，<strong>每</strong>
<strong>个表都会对应一条记录，但是这些记录的id值都是相同的</strong>，sql为生产问题分析中的sql</p>
<p><img src="image-20220120201330427.png" alt="image-20220120201330427"></p>
<p>在<strong>连接查询</strong>的执行计划中，每个表都会对应一条记录，<strong>这些记录的id列的值是相同的</strong>，<strong>出现在前边的表表示驱动表，出现在后边的表表示被驱动表</strong></p>
<blockquote>
<p>对于包含子查询的查询语句来说，就可能涉及多个SELECT 关键字，所以在包含子查询的查询语句的执行计划中，每个SELECT 关键字都会对应一个唯一的id 值，但是<strong>查询优化器可能对涉及子查询的查询语句</strong>进行重写，从而转换为连接查询,。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了</p>
</blockquote>
<p>总结：</p>
<p>表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为 <code>null</code> 时表示一个结果集，不需要使用它查询，常出现在包含 <code>union</code>等查询语句中</li>
</ul>
<h3 id="select_type">select_type</h3>
<hr>
<p>每一个SELECT 关键字代表的小查询都定义了一个称之为select_type 的属性，意思是我们只要知道了某个小查询的select_type 属性，就知道了这个小查询在整个大查询中扮演了一个什么角色,具体详情如下：</p>
<ul>
<li>
<p>SIMPLE</p>
<p>查询语句中不包含<strong>UNION</strong> 或者<strong>子查询</strong>的查询都算作是SIMPLE 类型,例如</p>
<pre><code class="language-sql">SELECT * FROM s1;
SELECT * FROM s1 INNER JOIN s2;
</code></pre>
</li>
<li>
<p>PRIMARY</p>
<p>对于包含UNION 、UNION ALL 或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type 值就是PRIMARY</p>
</li>
<li>
<p>UNION</p>
<p>对于包含UNION 或者UNION ALL 的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type 值就是UNION</p>
</li>
<li>
<p>UNION RESULT</p>
<p>MySQL 选择使用临时表来完成UNION 查询的去重工作，针对该临时表的查询的select_type 就是UNION
RESULT</p>
</li>
<li>
<p>SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的semi-join 的形式，并且该子查询是<strong>不相关子查询</strong>，并且查询
优化器决定采用将该<strong>子查询物化的方案来执行该子查询时</strong>，该子查询的第一个SELECT 关键字代表的那个查
询的select_type 就是SUBQUERY</p>
</li>
<li>
<p>DEPENDENT SUBQUERY</p>
<p>如果包含子查询的查询语句不能够转为对应的semi-join 的形式，并且该子查询是相关子查询，则该子查询
的第一个SELECT 关键字代表的那个查询的select_type 就是DEPENDENT SUBQUERY</p>
</li>
<li>
<p>DEPENDENT UNION</p>
<p>在包含UNION 或者UNION ALL 的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小
查询之外，其余的小查询的select_type 的值就是DEPENDENT UNION</p>
</li>
<li>
<p>DERIVED</p>
<p>对于采用物化的方式执行的包含<strong>派生表</strong>的查询，该派生表对应的子查询的select_type 就是DERIVED</p>
</li>
<li>
<p>MATERIALIZED</p>
<p>当查询优化器在执行包含子查询的语句时，选择<strong>将子查询物化之后与外层查询进行连接查询时</strong>，该子查询对应的select_type 属性就是MATERIALIZED</p>
</li>
</ul>
<h3 id="type">type</h3>
<hr>
<p>我们前边说过执行计划的一条记录就代表着MySQL 对某个表的执行查询时的访问方法，其中的type 列就表明了
这个访问方法是个啥，完整的访问方法如下： system ， const ，eq_ref ， ref ， fulltext ， ref_or_null ， index_merge ， unique_subquery ， index_subquery ，range ， index ， ALL。</p>
<ul>
<li>
<p>system</p>
<p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的
访问方法就是system 。比方说我们新建一个MyISAM 表，并为其插入一条记录</p>
</li>
<li>
<p>const</p>
<p>就是当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const</p>
</li>
<li>
<p>eq_ref</p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是eq_ref</p>
</li>
<li>
<p>ref</p>
<p>通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p>
</li>
<li>
<p>ref_or_null</p>
<p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL 值时，那么对该表的访问方法就可能是
ref_or_null</p>
</li>
<li>
<p>index_merge</p>
<p>一般情况下对于某个表的查询只能使用到一个索引，但我们唠叨单表访问方法时特意强调了在某些场景下可
以使用Intersection 、Union 、Sort-Union 这三种索引合并的方式来执行查询</p>
</li>
<li>
<p>unique_subquery</p>
<p>类似于两表连接中被驱动表的eq_ref 访问方法， unique_subquery 是针对在一些包含<strong>IN 子查询</strong>的查询语
句中，如果查询优化器决定将<strong>IN 子查询转换为EXISTS 子查询</strong>，而且子查询可以使用到<strong>主键进行等值匹配</strong>的
话，那么该子查询执行计划的type 列的值就是unique_subquery</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
</code></pre>
</li>
<li>
<p>index_subquery</p>
<p>index_subquery 与unique_subquery 类似，只不过访问子查询中的表时使用的是普通的索引</p>
<pre><code> ```
 SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 = s2.key1) OR key3 = 'a';
 ```
</code></pre>
</li>
<li>
<p>range</p>
<p>使用索引获取某些范围区间的记录，那么就可能使用到range 访问方法</p>
</li>
<li>
<p>index</p>
<p>当我们可以使用<strong>索引覆盖</strong>，但需要扫描全部的索引记录时，该表的访问方法就是index</p>
<pre><code class="language-sql">SELECT key_part2 FROM s1 WHERE key_part3 = 'a';
上述查询中的搜索列表中只有key_part2 一个列，而且搜索条件中也只有key_part3 一个列，这两个列又恰
好包含在idx_key_part 这个索引中，可是搜索条件key_part3 不能直接使用该索引进行ref 或者range 方
式的访问，只能扫描整个idx_key_part 索引的记录，所以查询计划的type 列的值就是index
</code></pre>
</li>
<li>
<p>All</p>
<p>全表扫描</p>
</li>
</ul>
<p>一般来说，<strong>这些访问方法</strong>按照我们<strong>介绍它们的顺序性能依次变差</strong>。<strong>其中除了All 这个访问方法外，其余的访问方</strong>
<strong>法都能用到索引，除了index_merge 访问方法外，其余的访问方法都最多只能用到一个索引</strong>。</p>
<h3 id="possible_keys和key">possible_keys和key</h3>
<p>possible_keys 列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些， key 列表示实际用到的索引有哪些,<strong>possible_keys列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引</strong>。</p>
<h3 id="key_len">key_len</h3>
<p>key_len 列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的
变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100) ，使用的字符集是utf8 ，那么该列实际占
用的最大存储空间就是100 × 3 = 300 个字节。</li>
<li>如果该索引列可以存储NULL 值，则key_len 比不可以存储NULL 值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h3 id="ref-1">ref</h3>
<p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const 、eq_ref 、ref 、ref_or_null 、
unique_subquery 、index_subquery 其中之一时， ref 列展示的就是与索引列作等值匹配的东东是个啥，比如
只是一个常数(const)或者是某个列。还是这个图</p>
<p><img src="image-20220120201330427.png" alt="image-20220120201330427"></p>
<h3 id="rows">rows</h3>
<p>执行计划的rows 列就代表预计扫描的索引记录行数</p>
<h3 id="extra">Extra</h3>
<p>Extra 列是用来说明一些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL 到底将如何执行给定的查询语句</p>
<ul>
<li>
<p>Using index
当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用<strong>索引覆盖</strong>的情况下，在Extra 列将会提示该额外信息</p>
</li>
<li>
<p>Using index condition</p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引</p>
</li>
</ul>
<pre><code class="language-sql">SELECT * FROM s1 WHERE key1 &gt; 'z' AND key1 LIKE '%a';
</code></pre>
<p>其中的key1 &gt; &lsquo;z&rsquo; 可以使用到索引，但是key1 LIKE &lsquo;%a&rsquo; 却无法使用到索引，在以前版本的MySQL 中，是按照下边步骤来执行这个查询的：</p>
<ul>
<li>
<p>先根据key1 &gt; &lsquo;z&rsquo; 这个条件，从二级索引idx_key1 中获取到对应的二级索引记录。</p>
</li>
<li>
<p>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合key1 LIKE &lsquo;%a&rsquo; 这个条件，将符合条件的记录加入到最后的结果集。</p>
<p>但是虽然key1 LIKE &lsquo;%a&rsquo; 不能组成范围区间参与range 访问方法的执行，但这个条件毕竟只涉及到了
<strong>key1</strong> 列，所以设计MySQL 的大叔把上边的步骤改进了一下：</p>
</li>
<li>
<p>先根据key1 &gt; &lsquo;z&rsquo; 这个条件，定位到二级索引idx_key1 中对应的二级索引记录</p>
</li>
<li>
<p>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足key1 LIKE &lsquo;%a&rsquo; 这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</p>
</li>
<li>
<p>对于满足key1 LIKE &lsquo;%a&rsquo; 这个条件的二级索引记录执行回表操作。</p>
</li>
</ul>
<p>我们说<strong>回表操作其实是一个随机IO</strong> ，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去<strong>好多回表操作的成本</strong>。设计MySQL 的大叔们把他们的这个改进称之为<strong>索引条件下推</strong></p>
<p>如果在<strong>查询语句的执行过程中将要使用索引条件下推</strong>这个特性在Extra 列中将会显示Using index condition</p>
<ul>
<li>
<p>Using where</p>
<ul>
<li>
<p>当使用<strong>全表扫描</strong>来执行对某个表的查询，并且该语句的WHERE 子句中有针对该表的搜索条件时，在
Extra 列中会提示上述额外信息。</p>
</li>
<li>
<p>当使用索引访问来执行对某个表的查询，并且该语句的WHERE 子句中有除了该索引包含的列之外的其他搜索条件时，在Extra 列中也会提示上述额外信息。</p>
<pre><code class="language-sql">SELECT * FROM s1 WHERE common_field = 'a';
key1是索引，但是common_field不是
SELECT * FROM s1 WHERE key1 = 'a' AND common_field = 'a';
</code></pre>
</li>
</ul>
</li>
<li>
<p>Using join buffer (Block Nested Loop)</p>
<p>在连接查询执行过程中，<strong>当被驱动表不能有效的利用索引加快访问速度</strong>， MySQL 一般会为其分配一块名叫
join buffer 的内存块来加快查询速度，也就是我们所讲的基于块的<code>嵌套循环算法</code></p>
</li>
<li>
<p>Not exists</p>
<p>当我们使用左（外）连接时，如果WHERE 子句中包含要求被驱动表的某个列等于NULL 值的搜索条件，而且
那个列又是不允许存储NULL 值的</p>
<pre><code>SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;
</code></pre>
<p>s1 表是驱动表， s2 表是被驱动表， s2.id 列是不允许存储NULL 值的，而WHERE 子句中又包含s2.id IS NULL 的搜索条件，这意味着必定是<strong>驱动表的记录在被驱动表中找不到匹配ON 子句条件的记录才会把该驱动表的记录加入到最终的结果集</strong>，所以对于某条驱动表中的记录来说，如果能在被驱动表中找到1条符合ON 子句条件的记录，那么该驱动表的记录就不会被加入到最终的结果集，也就是说**我们没有必要到被驱动表中找到全部符合ON子句条件的记录，**其实就是说不需要查s2表了吗？</p>
</li>
<li>
<p>Using intersect(&hellip;) 、Using union(&hellip;) 和Using sort_union(&hellip;)</p>
<p>如果执行计划的Extra 列出现了Using intersect(&hellip;) 提示，说明准备使用Intersect 索引合并的方式执行查询，括号中的&hellip; 表示需要进行索引合并的索引名称；如果出现了Using union(&hellip;) 提示，说明准备使用Union 索引合并的方式执行查询；出现了Using sort_union(&hellip;) 提示，说明准备使用Sort-Union 索引合并的方式执行查询。</p>
</li>
<li>
<p>Using filesort</p>
<p>排序操作无法使用到索引，只能在内存中（记录较少的时候）或者磁盘中（记录较多的时候）进行排序，设计MySQL 的大叔把这种在内存中或者磁盘上进行排序的方式统称为文件排序</p>
</li>
<li>
<p>Using temporary</p>
<p>在许多查询的执行过程中， MySQL 可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在
执行许多包含DISTINCT 、GROUP BY 、UNION 等子句的查询过程中，如果不能有效利用索引来完成查询，
MySQL 很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划
的Extra 列将会显示Using temporary，<strong>MySQL 会在包含GROUP BY子句的查询中默认添加上ORDER BY 子句</strong></p>
<pre><code class="language-sql">这两条语句作用相等
select trans_amt from t_bls_order_detail group by trans_amt;
select trans_amt from t_bls_order_detail group by trans_amt order by trans_amt;
</code></pre>
<p><strong>执行计划中出现Using temporary 并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表</strong></p>
</li>
<li>
<p>Start temporary, End temporary</p>
<p>我们前边唠叨子查询的时候说过，查询优化器会优先尝试将IN 子查询转换成semi-join ，而semi-join 又
有好多种执行策略，当执行策略为DuplicateWeedout 时，也就是通过建立临时表来实现为外层查询中的记
录进行去重操作时，驱动表查询执行计划的Extra 列将显示Start temporary 提示，被驱动表查询执行计划
的Extra 列将显示End temporary 提示，</p>
</li>
<li>
<p>LooseScan</p>
<p>在将In 子查询转为semi-join 时，如果采用的是LooseScan 执行策略，则在驱动表执行计划的Extra 列就是显示LooseScan</p>
</li>
<li>
<p>FirstMatch(tbl_name)</p>
<p>在将In 子查询转为semi-join 时，如果采用的是FirstMatch 执行策略，则在被驱动表执行计划的Extra列就是显示FirstMatch(tbl_name)</p>
</li>
</ul>
<h3 id="json格式的执行计划">Json格式的执行计划</h3>
<p>我们上边介绍的EXPLAIN 语句输出中缺少了一个衡量执行计划好坏的重要属性 —— <strong>成本</strong>。不过设计MySQL 的大
叔贴心的为我们提供了一种查看某个执行计划花费的成本的方式：</p>
<p><strong>在EXPLAIN 单词和真正的查询语句中间加上FORMAT=JSON</strong> 。</p>
<pre><code class="language-json">{
  &quot;query_block&quot;: {
    # 整个查询语句只有1个SELECT关键字，该关键字对应的id号为1
    &quot;select_id&quot;: 1,
    &quot;ordering_operation&quot;: {
      &quot;using_filesort&quot;: true,
      &quot;grouping_operation&quot;: {
        &quot;using_temporary_table&quot;: true,
        &quot;using_filesort&quot;: false,
      # 几个表之间采用嵌套循环连接算法执行
        &quot;nested_loop&quot;: [
      # 以下是参与嵌套循环连接算法的各个表的信息
          {
            &quot;table&quot;: {
      # 第一个表是驱动表
              &quot;table_name&quot;: &quot;o&quot;,
              &quot;access_type&quot;: &quot;range&quot;,
              &quot;possible_keys&quot;: [
                &quot;t_bls_order_detail_order_id_index&quot;,
                &quot;ID_TIME&quot;
              ],
              &quot;key&quot;: &quot;ID_TIME&quot;,
              &quot;used_key_parts&quot;: [
                &quot;shop_id&quot;,
                &quot;create_time&quot;
              ],
              &quot;key_length&quot;: &quot;105&quot;,
              &quot;rows&quot;: 21,
              &quot;filtered&quot;: 76.19,
              &quot;index_condition&quot;: &quot;((`dingjia_yszx`.`o`.`shop_id` = '1333584333856333855') and (`dingjia_yszx`.`o`.`create_time` &gt;= '2021-12-30 00:00:00') and (`dingjia_yszx`.`o`.`create_time` &lt;= '2021-12-30 23:59:59'))&quot;,
              &quot;attached_condition&quot;: &quot;((`dingjia_yszx`.`o`.`status` = '1') and (`dingjia_yszx`.`o`.`order_id` is not null))&quot;
            }
          },
          {
            &quot;table&quot;: {
              &quot;table_name&quot;: &quot;f&quot;,
              &quot;access_type&quot;: &quot;eq_ref&quot;,
              &quot;possible_keys&quot;: [
                &quot;PRIMARY&quot;
              ],
              &quot;key&quot;: &quot;PRIMARY&quot;,
              &quot;used_key_parts&quot;: [
                &quot;order_id&quot;
              ],
              &quot;key_length&quot;: &quot;98&quot;,
              &quot;ref&quot;: [
                &quot;dingjia_yszx.o.order_id&quot;
              ],
              &quot;rows&quot;: 1,
              &quot;filtered&quot;: 100,
              &quot;attached_condition&quot;: &quot;((`dingjia_yszx`.`f`.`status` = '1') or ((`dingjia_yszx`.`f`.`trans_amt` = `dingjia_yszx`.`f`.`refund_total_amt`) and (`dingjia_yszx`.`f`.`status` = '3')))&quot;
            }
          },
          {
            &quot;table&quot;: {
              &quot;table_name&quot;: &quot;p&quot;,
              &quot;access_type&quot;: &quot;ALL&quot;,
              &quot;possible_keys&quot;: [
                &quot;idx_product_bar_barid&quot;,
                &quot;idx_product_bar_shopid&quot;
              ],
              &quot;rows&quot;: 784,
              &quot;filtered&quot;: 50.383,
              &quot;using_join_buffer&quot;: &quot;Block Nested Loop&quot;,
              &quot;attached_condition&quot;: &quot;(((`dingjia_yszx`.`p`.`product_id` = `dingjia_yszx`.`o`.`product_id`) and (`dingjia_yszx`.`p`.`shop_id` = `dingjia_yszx`.`o`.`shop_id`)) and (`dingjia_yszx`.`p`.`bar_id` is not null))&quot;
            }
          },
          {
            &quot;table&quot;: {
              &quot;table_name&quot;: &quot;s&quot;,
              &quot;access_type&quot;: &quot;eq_ref&quot;,
              &quot;possible_keys&quot;: [
                &quot;PRIMARY&quot;
              ],
              &quot;key&quot;: &quot;PRIMARY&quot;,
              &quot;used_key_parts&quot;: [
                &quot;bar_id&quot;
              ],
              &quot;key_length&quot;: &quot;98&quot;,
              &quot;ref&quot;: [
                &quot;dingjia_yszx.p.bar_id&quot;
              ],
              &quot;rows&quot;: 1,
              &quot;filtered&quot;: 100,
              &quot;attached_condition&quot;: &quot;(`dingjia_yszx`.`s`.`shop_id` = `dingjia_yszx`.`o`.`shop_id`)&quot;
            }
          }
        ]
      }
    }
  }
}
</code></pre>
<h3 id="extented-explain">Extented EXPLAIN</h3>
<p>最后，设计MySQL 的大叔还为我们留了个彩蛋，在我们使用EXPLAIN 语句查看了某个查询的执行计划后，紧接着
还可以使用<strong>SHOW WARNINGS</strong> 语句查看与这个查询的执行计划有关的一些扩展信息</p>
<p>SHOW WARNINGS 展示出来的信息有三个字段，分别是Level 、Code 、Message 。我们最常见的就是Code 为1003 的信息，当Code 值为1003 时， Message 字段展示的信息类似于查询优化器将我们的查询语句重写后的语句。</p>
<h2 id="事务的隔离级别与mvcc">事务的隔离级别与MVCC</h2>
<p>复习一些基础概念</p>
<blockquote>
<p>事务：是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，</p>
</blockquote>
<p>事务的四个特征(ACID)</p>
<ul>
<li>
<p>原子性（Atomicity）：事务包含的 各项操作在一次执行中，要么执行成功，要么全部不执行</p>
</li>
<li>
<p>一致性（Consistency）:事务执行的结果必须是使数据库从一个一致性状态到另一个一致性状态</p>
</li>
<li>
<p>隔离性（Isolation）：并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）</p>
</li>
<li>
<p>持久性（Durability）：事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。</p>
</li>
</ul>
<h3 id="事务并发执行遇到的问题">事务并发执行遇到的问题</h3>
<hr>
<ul>
<li>脏写（ Dirty Write ）: 如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了脏写</li>
<li>脏读（ Dirty Read ）：一个事务读到了另一个未提交事务修改过的数据，A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。</li>
<li>不可重复读（Non-Repeatable Read）：前后多次读取，数据内容不一致。事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了。</li>
<li>幻读（Phantom）：一个事务先根据某些条件查询出一些记录，之后<strong>另一个事务又向表中插入了符合这些条件的记录</strong>，原先的事务再次按照该条件查询时，<strong>能把另一个事务插入的记录也读出来</strong></li>
</ul>
<h3 id="sql标准中的四种隔离级别">SQL标准中的四种隔离级别</h3>
<p>这些问题按照严重性来排一下序：
脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读
<strong>设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生</strong>。有一帮人（并不是设计MySQL 的大叔们）制定了一个所谓的SQL标准，在标准中设立了4个隔离级别：</p>
<ul>
<li>READ UNCOMMITTED ：未提交读。可能发生脏读、不可重复读和幻读问题。</li>
<li>READ COMMITTED ：已提交读。可能发生不可重复读和幻读问题，但是不可以发生脏读问题。</li>
<li>REPEATABLE READ ：可重复读。可能发生幻读问题，但是不可以发生脏读和不可重复读的问题。</li>
<li>SERIALIZABLE ：可串行化。各种问题都不可以发生。</li>
</ul>
<h3 id="mvcc">MVCC</h3>
<hr>
<p><strong>多版本并发控制</strong>技术的英文全称是 <strong>Multiversion Concurrency Control</strong>，简称 <strong>MVCC</strong>。</p>
<p><strong>多版本并发控制（MVCC）</strong> 是通过保存数据在某个时间点的<strong>快照</strong>来实现并发控制的。也就是说，<strong>不管事务执行多长时间，事务内部看到的数据是不受其它事务影响的</strong>，根据事务开始的时间不同，<strong>每个事务对同一张表，同一时刻看到的数据可能是不一样的</strong>。</p>
<p>简单来说，<strong>多版本并发控制</strong> 的思想就是保存数据的历史版本，通过对数据行的多个版本管理来实现数据库的并发控制。这样我们就可以通过比较版本号决定数据是否显示出来，读取数据的时候不需要加锁也可以保证事务的隔离效果。</p>
<p>可以认为 <strong>多版本并发控制（MVCC）</strong> 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行</p>
<h4 id="版本链">版本链</h4>
<p>对于使用InnoDB 存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p>
<ul>
<li>trx_id ：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id 赋值给trx_id 隐藏列。</li>
<li>roll_pointer ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏
列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p>在hero表中插入一条记录，假设插入该记录的<code>事务id </code>为80 ，那么此刻该条记录的示意图如下所示：</p>
<p><img src="image-20220208171641304.png" alt="image-20220208171641304"></p>
<blockquote>
<p>实际上insert undo只在事务回滚时起作用，当事务提交后，该类型的undo日志就没用了，它占用的Undo Log Segment也会被系统回收（也就是该undo日志占用的Undo页面链表要么被重用，要么被释放）。
虽然真正的insert undo日志占用的存储空间被释放了，但是roll_pointer的值并不会被清除，roll_pointer属性占用7个字节，第一个比特位就标记着它指向的undo日志的类型，如果该比特位的值为1时，就代表着它指向的undo日志类型为insert undo。所以我们之后在画图时都会把insert undo给去掉，大家留意一下就好了。</p>
</blockquote>
<p>假设之后两个事务id 分别为100 、200 的事务对这条记录进行UPDATE 操作，操作流程如下：</p>
<p><img src="image-20220208171850345.png" alt="image-20220208171850345"></p>
<blockquote>
<p>能不能在两个事务中交叉更新同一条记录呢？哈哈，这不就是一个事务修改了另一个未提交事务修改过的数据，沦为了脏写了么？InnoDB使用锁来保证不会有脏写情况的发生，也就是在第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。关于锁的更多细节我们后续的文章中再唠叨哈～</p>
</blockquote>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer 属性（ INSERT 操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<p><img src="image-20220208172027389.png" alt="image-20220208172027389"></p>
<p>对该记录每次更新后，<strong>都会将旧值放到一条undo日志中</strong>，就算是该记录的一个旧版本，随着更新次数的增多，<strong>所有的版本都会被roll_pointer 属性连接成一个链表</strong>，我们把这个链表称之为<strong>版本链</strong>，<strong>版本链的头节点就是当前记录最新的值</strong>。另外，每个版本中还包含生成该版本时对应的事务id</p>
<h4 id="readview">ReadView</h4>
<p>对于使用READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用SERIALIZABLE 隔离级别的事务来说，设计InnoDB 的大叔规定使用加锁的方式来访问记录;对于使用<strong>READ COMMITTED 和REPEATABLE READ 隔离级别的事务</strong>来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>。为此，设计InnoDB 的大叔提出了一个ReadView 的概念，这个ReadView 中主要包含4个比较重要的内容:</p>
<ul>
<li>
<p>m_ids ：表示在生成ReadView 时当前系统中活跃的读写事务的事务id 列表。</p>
</li>
<li>
<p>min_trx_id ：表示在生成ReadView 时当前系统中活跃的读写事务中最小的事务id ，也就是m_ids 中的最小值。</p>
</li>
<li>
<p>max_trx_id ：表示生成ReadView 时系统中应该分配给下一个事务的id 值。</p>
<blockquote>
<p>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。</p>
</blockquote>
</li>
<li>
<p>creator_trx_id ：表示生成该ReadView 的事务的事务id 。
我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</li>
</ul>
<p>在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ul>
<li>如果被访问版本的trx_id 属性值与ReadView 中的creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id 属性值小于ReadView 中的min_trx_id 值，表明生成该版本的事务在当前事务生成ReadView 前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id 属性值大于ReadView 中的max_trx_id 值，表明生成该版本的事务在当前事务生成ReadView 后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id 属性值在ReadView 的min_trx_id 和max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在m_ids 列表中，如果在，说明创建ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<p>在MySQL 中， READ COMMITTED 和REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。假设现在表hero 中只有一条由事务id 为80 的事务插入的一条记录</p>
<h5 id="read-committed--每次读取数据前都生成一个readview">READ COMMITTED —— 每次读取数据前都生成一个ReadView</h5>
<p>比方说现在系统里有两个事务id 分别为100 、200 的事务在执行：</p>
<pre><code class="language-sql">ransaction 100

BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;

Transaction 200

BEGIN;

更新了一些别的表的记录

...
</code></pre>
<p>再次强调一遍，**事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。**所以我们才在Transaction 200中更新一些别的表的记录，目的是让它分配事务id。</p>
<p>此刻，表hero 中number 为1 的记录得到的版本链表如下所示：</p>
<p><img src="image-20220208173720982.png" alt="image-20220208173720982"></p>
<p>假设现在有一个使用READ COMMITTED 隔离级别的事务开始执行：</p>
<pre><code class="language-sql">BEGIN;

SELECT1：Transaction 100、200未提交

SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'
</code></pre>
<p>这个SELECT1 的执行过程如下：</p>
<ul>
<li>在执行SELECT 语句时会先生成一个ReadView ， ReadView 的m_ids 列表的内容就是[100, 200] ，
min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是&rsquo;张飞' ，该版本的
trx_id 值为100 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。
下一个版本的列name 的内容是&rsquo;关羽' ，该版本的trx_id 值也为100 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;刘备' ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为&rsquo;刘备' 的记录。</li>
</ul>
<p>之后，我们把事务id 为100 的事务提交一下，就像这样：</p>
<pre><code class="language-sql">Transaction 100

BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;
COMMIT;
然后再到事务id 为200 的事务中更新一下表hero 中number 为1 的记录：

Transaction 200

BEGIN;

更新了一些别的表的记录

...
UPDATE hero SET name = '赵云' WHERE number = 1;
UPDATE hero SET name = '诸葛亮' WHERE number = 1;
</code></pre>
<p>此刻，表hero 中number 为1 的记录的版本链就长这样：</p>
<p><img src="image-20220208174133973.png" alt="image-20220208174133973"></p>
<p>然后再到刚才使用READ COMMITTED 隔离级别的事务中继续查找这个number 为1 的记录，如下：</p>
<pre><code>BEGIN;

SELECT1：Transaction 100、200均未提交

SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'

SELECT2：Transaction 100提交，Transaction 200未提交

SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'张飞'
</code></pre>
<p>这个SELECT2 的执行过程如下：</p>
<ul>
<li>在执行SELECT 语句时会<strong>又会单独生成</strong>一个ReadView ，该ReadView 的m_ids 列表的内容就是[200] （ 事务id 为100 的那个事务已经提交了，所以再次生成快照时就没有它了）， min_trx_id 为200 ，max_trx_id 为201 ， creator_trx_id 为0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是&rsquo;诸葛亮' ，该版本的trx_id 值为200 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;赵云' ，该版本的trx_id 值为200 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;张飞' ，该版本的trx_id 值为100 ，小于ReadView 中的min_trx_id 值200 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为&rsquo;张飞' 的记录。</li>
</ul>
<p>以此类推，如果之后事务id 为200 的记录也提交了，再此在使用READ COMMITTED 隔离级别的事务中查询表hero 中number 值为1 的记录时，得到的结果就是&rsquo;诸葛亮' 了，具体流程我们就不分析了。总结一下就是：<strong>使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView</strong>。</p>
<h5 id="repeatable-read--在第一次读取数据时生成一个readview">REPEATABLE READ —— 在第一次读取数据时生成一个ReadView</h5>
<p>对于使用REPEATABLE READ 隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView ，之后的查询就不会重复生成了。</p>
<p>比方说现在系统里有两个事务id 分别为100 、200 的事务在执行：</p>
<pre><code>Transaction 100

BEGIN;
UPDATE hero SET name = '关羽' WHERE number = 1;
UPDATE hero SET name = '张飞' WHERE number = 1;

Transaction 200

BEGIN;

更新了一些别的表的记录
</code></pre>
<p>此刻，表hero 中number 为1 的记录得到的版本链表如下所示：</p>
<p><img src="image-20220208175715588.png" alt="image-20220208175715588"></p>
<p>假设现在有一个使用REPEATABLE READ 隔离级别的事务开始执行：</p>
<pre><code class="language-sql"># 使用REPEATABLE READ隔离级别的事务
BEGIN;
# SELECT1：Transaction 100、200未提交
SELECT * FROM hero WHERE number = 1; # 得到的列name的值为'刘备'
</code></pre>
<p>这个SELECT1 的执行过程如下：</p>
<ul>
<li>在执行SELECT 语句时会先生成一个ReadView ， ReadView 的m_ids 列表的内容就是[100, 200] ，min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是&rsquo;张飞' ，该版本的trx_id 值为100 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;关羽' ，该版本的trx_id 值也为100 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;刘备' ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name 为&rsquo;刘备' 的记录。</li>
</ul>
<p>之后，我们把事务id 为100 的事务提交一下,然后再到事务id 为200 的事务中更新一下表hero 中number 为1 的记录：</p>
<pre><code class="language-sql"># Transaction 200
BEGIN;
# 更新了一些别的表的记录
...
UPDATE hero SET name = '赵云' WHERE number = 1;
UPDATE hero SET name = '诸葛亮' WHERE number = 1;
</code></pre>
<p>此刻，表hero 中number 为1 的记录的版本链就长这样：</p>
<p><img src="image-20220208180026139.png" alt="image-20220208180026139"></p>
<p>之后，我们把事务id 为100 的事务提交一下,执行过程如下：</p>
<ul>
<li>因为当前事务的隔离级别为REPEATABLE READ ，而之前在执行SELECT1 时已经生成过ReadView 了，所以此时直接复用之前的ReadView ，之前的ReadView 的m_ids 列表的内容就是[100, 200] ， min_trx_id 为100 ， max_trx_id 为201 ， creator_trx_id 为0 。</li>
<li>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name 的内容是&rsquo;诸葛亮' ，该版本的trx_id 值为200 ，在m_ids 列表内，所以不符合可见性要求，根据roll_pointer 跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;赵云' ，该版本的trx_id 值为200 ，也在m_ids 列表内，所以也不符合要求，继续跳到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;张飞' ，该版本的trx_id 值为100 ，而m_ids 列表中是包含值为100 的事务id 的，所以该版本也不符合要求，同理下一个列name 的内容是&rsquo;关羽' 的版本也不符合要求。继续跳
到下一个版本。</li>
<li>下一个版本的列name 的内容是&rsquo;刘备' ，该版本的trx_id 值为80 ，小于ReadView 中的min_trx_id 值100 ，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c 为&rsquo;刘备' 的记录。</li>
</ul>
<p><strong>也就是说两次SELECT 查询得到的结果是重复的，记录的列c 值都是&rsquo;刘备' ，这就是可重复读的含义</strong>。如果我们之后再把事务id 为200 的记录提交了，然后再到刚才使用REPEATABLE READ 隔离级别的事务中继续查找这个number 为1 的记录，得到的结果还是&rsquo;刘备'。</p>
<h5 id="mvcc小结">MVCC小结</h5>
<p>所谓的MVCC （Multi-Version Concurrency Control ，多版本并发控制）<strong>指的就是在使用READ COMMITTD 、REPEATABLE READ 这两种隔离级别的事务在执行普通的SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能</strong>。</p>
<p>READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：<strong>生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</strong></p>
<blockquote>
<p>我们之前说执行DELETE语句或者更新主键的UPDATE语句并不会立即把对应的记录完全从页面中删除，而是执行一个所谓的delete mark操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVCC服务的，大家可以对比上边举的例子自己试想一下怎么使用。
另外，所谓的MVCC只是在我们进行普通的SEELCT查询时才生效，截止到目前我们所见的所有SELECT语句都算是普通的查询，至于啥是个不普通的查询，我们稍后再说哈</p>
</blockquote>
<h2 id="mysql中的锁">mysql中的锁</h2>
<p>mysql中的锁，说起来简单，但一直没有深入研究过，现在仔细看看</p>
<h3 id="解决并发事务带来问题的两种基本方式">解决并发事务带来问题的两种基本方式</h3>
<p>并发事务访问相同记录的情况大致可以划分为3种：</p>
<ol>
<li>
<p>读-读情况：即并发事务相继读取相同的记录。</p>
</li>
<li>
<p>写-写情况：即并发事务相继对相同的记录做出改动。</p>
<p>在这种情况下会发生<strong>脏写</strong>的问题，<strong>任何一种隔离级别</strong>都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们<strong>排队执行</strong>，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在<strong>事务执行前本来是没有锁的</strong>，也就是说一开始是没有锁结构和记录进行关联的，当一个事务想对这条记录做改动时，首先会<strong>看看内存中有没有与这条记录关联的锁结构</strong>，当没有的时候就会在内存中生成一个锁结构与之关联。比方说事务T1 要对这条记录做改动，就需要生成一个锁结构与之关联：</p>
</li>
</ol>
<p><img src="image-20220209111730758.png" alt="image-20220209111730758"></p>
<p>​	其实在锁结构里有很多信息，不过为了简化理解，我们现在只把两个比较重要的属性拿了出来：</p>
<ul>
<li>trx信息：代表这个锁结构是哪个事务生成的。</li>
<li>is_waiting ：代表当前事务是否在等待。</li>
</ul>
<p>如图所示，当事务T1 改动了这条记录后，<strong>就生成了一个锁结构与该记录关联</strong>，<strong>因为之前没有别的事务为这条记录加锁，所以is_waiting 属性就是false</strong> ，我们把这个场景就称之为<strong>获取锁成功</strong>，或者<strong>加锁成功</strong>，然后就可以继续执行操作了。
在事务T1 提交之前，另一个事务T2 也想对该记录做改动，<strong>那么先去看看有没有锁结构与这条记录关联，发现有一个锁结构与之关联后，然后也生成了一个锁结构与这条记录关联，不过锁结构的is_waiting 属性值为true</strong> ，表示当前事务需要等待，我们把这个场景就称之为<strong>获取锁失败</strong>，或者<strong>加锁失败</strong>，或者没有成功的获取到锁，画个图表示就是这样：</p>
<p><img src="image-20220209112210931.png" alt="image-20220209112210931"></p>
<ol start="3">
<li>
<p>读-写或写-读情况：也就是一个事务进行读取操作，另一个进行改动操作。</p>
<p>这种情况下可能发生脏读、不可重复读、幻读的问题。mysql中有两种方式解决</p>
<ul>
<li>读操作利用多版本并发控制（ MVCC ），写操作进行加锁。读-写操作彼此并不冲突，性能更高</li>
<li>读、写操作都采用加锁的方式。</li>
</ul>
</li>
</ol>
<blockquote>
<p>脏读的产生是因为当前事务读取了另一个未提交事务写的一条记录，如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题的产生了。</p>
<p>不可重复读的产生是因为当前事务先读取一条记录，另外一个事务对该记录做了改动之后并提交之后，当前事务再次读取时会获得不同的值，如果在当前事务读取记录时就给该记录加锁，那么另一个事务就无法修改该记录，自然也不会发生不可重复读了。</p>
<p>幻读问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，我们把新插入的那些记录称之为幻影记录。采用加锁的方式解决幻读问题就有那么一丢丢麻烦了，因为当前事务在第一次读取记录时那些幻影记录并不存在，所以读取的时候加锁就有点尴尬 —— 因为你并不知道给谁加锁，没关系，这难不倒设计InnoDB的大叔的，我们稍后揭晓答案，稍安勿躁。</p>
</blockquote>
<h3 id="一致性读consistent-reads">一致性读（Consistent Reads）</h3>
<p><strong>事务</strong>利用<strong>MVCC</strong> 进行的读取操作称之为<strong>一致性读</strong>，或者<strong>一致性无锁读</strong>，有的地方也称之为快照读。所有普通的SELECT 语句（ plain SELECT ）在READ COMMITTED 、REPEATABLE READ 隔离级别下都算是一致性读，比方说：
SELECT * FROM t;
SELECT * FROM t1 INNER JOIN t2 ON t1.col1 = t2.col2
<strong>一致性读并不会对表中的任何记录做加锁操作</strong>，其他事务可以自由的对表中的记录做改动。</p>
<h3 id="锁定读locking-reads">锁定读（Locking Reads）</h3>
<hr>
<h4 id="共享锁和独占锁">共享锁和独占锁</h4>
<ul>
<li>共享锁，英文名： Shared Locks ，简称S锁。<strong>在事务要读取一条记录时，需要先获取该记录的S锁</strong>。</li>
<li>独占锁，也常称排他锁，英文名： Exclusive Locks ，简称X锁。<strong>在事务要改动一条记录时，需要先获取该记录的X锁。</strong></li>
</ul>
<p>假如事务T1 首先获取了一条记录的S锁之后，事务T2 接着也要访问这条记录：</p>
<ul>
<li>如果事务T2 想要再获取一个记录的S锁，那么事务T2 也会获得该锁，也就意味着事务T1 和T2 在该记录上同时持有S锁。</li>
<li>如果事务T2 想要再获取一个记录的X锁，那么此操作会被阻塞，直到事务T1 提交之后将S锁释放掉。</li>
<li>如果事务T1 首先获取了一条记录的X锁之后，那么不管事务T2 接着想获取该记录的S锁还是X锁都会被阻塞，直到事务T1 提交。</li>
</ul>
<p>所以我们说<strong>S锁和S锁是兼容的， S锁和X锁是不兼容的， X锁和X锁也是不兼容的</strong></p>
<p>我们前边说在采用加锁方式解决脏读、不可重复读、幻读这些问题时，读取一条记录时需要获取一下该记录的S锁，其实这是不严谨的，有时候想在读取记录时就获取记录的X锁，来禁止别的事务读写该记录，为此设计MySQL 的大叔提出了两种比较特殊的SELECT 语句格式：</p>
<pre><code class="language-sql">-- 对读取的记录加S锁：
SELECT ... LOCK IN SHARE MODE;
也就是在普通的SELECT 语句后边加LOCK IN SHARE MODE ，如果当前事务执行了该语句，那么它会为读取到的记录加S锁，这样允许别的事务继续获取这些记录的S锁（比方说别的事务也使用SELECT ... LOCK IN
SHARE MODE 语句来读取这些记录），但是不能获取这些记录的X锁（比方说使用SELECT ... FOR UPDATE
语句来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的X锁，那么它们会阻
塞，直到当前事务提交之后将这些记录上的S锁释放掉。
-- 对读取的记录加X锁：
SELECT ... FOR UPDATE;
也就是在普通的SELECT 语句后边加FOR UPDATE ，如果当前事务执行了该语句，那么它会为读取到的记录
加X锁，这样既不允许别的事务获取这些记录的S锁（比方说别的事务使用SELECT ... LOCK IN SHARE
MODE 语句来读取这些记录），也不允许获取这些记录的X锁（比方也说使用SELECT ... FOR UPDATE 语句
来读取这些记录，或者直接修改这些记录）。如果别的事务想要获取这些记录的S锁或者X锁，那么它们会
阻塞，直到当前事务提交之后将这些记录上的X锁释放掉。
</code></pre>
<h3 id="写操作">写操作</h3>
<hr>
<p>平常所用到的写操作无非是DELETE 、UPDATE 、INSERT 这三种：</p>
<ul>
<li>DELETE ：
对一条记录做DELETE 操作的过程其实是先在B+ 树中定位到这条记录的位置，然后获取一下这条记录的X锁，然后再执行delete mark 操作。我们也可以把这个<strong>定位待删除记录在B+ 树中位置的过程看成是一个获取X锁的锁定读</strong>。</li>
<li>UPDATE ：
在对一条记录做UPDATE 操作时分为三种情况：
<ul>
<li>如果<strong>未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化</strong>，则先在B+ 树中定位到这条记录的位置，然后<strong>再获取一下记录的X锁</strong>，最后在原记录的位置进行修改操作。其实我们也可以把这个<strong>定位待修改记录在B+ 树中位置的过程看成是一个获取X锁的锁定读</strong>。</li>
<li>如果<strong>未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化</strong>，则先在B+ 树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位<strong>待修改记录在B+ 树中位置的过程看成是一个获取X锁的锁定读</strong>，新插入的记录由INSERT 操作提供的<strong>隐式锁</strong>进行保护。</li>
<li>如果修改了该记录的键值，则相当于在原记录上做DELETE 操作之后再来一次INSERT 操作，加锁操作就需要按照DELETE 和INSERT 的规则进行了。</li>
</ul>
</li>
<li>INSERT ：
一般情况下，新插入一条记录的操作并不加锁，设计InnoDB 的大叔通过一种称之为隐式锁的东东来保护这条新插入的记录在本事务提交前不被别的事务访问</li>
</ul>
<h3 id="多粒度锁">多粒度锁</h3>
<p>我们前边提到的锁都是针对记录的，也可以被称之为行级锁或者行锁，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在表级别进行加锁，自然就被称之为表级锁或者表锁，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为共享锁（ S锁）和独占锁（ X锁）</p>
<p>如果一个事务给表加了S锁，那么：</p>
<ul>
<li>别的事务可以继续获得该表的S锁</li>
<li>别的事务可以继续获得该表中的某些记录的S锁(行锁)</li>
<li>别的事务不可以继续获得该表的X锁</li>
<li>别的事务不可以继续获得该表中的某些记录的X锁(行锁)</li>
</ul>
<p>给表加X锁：如果一个事务给表加了X锁（意味着该事务要独占这个表），那么：</p>
<ul>
<li>别的事务不可以继续获得该表的S锁</li>
<li>别的事务不可以继续获得该表中的某些记录的S锁(行锁)</li>
<li>别的事务不可以继续获得该表的X锁</li>
<li>别的事务不可以继续获得该表中的某些记录的X锁(行锁)</li>
</ul>
<p>在对表上表锁时有两个问题：</p>
<ul>
<li>对表整体上S锁，需要判断是否存在行 X锁</li>
<li>对表整体上X锁，需要判断是否存在行 X锁，行S锁</li>
</ul>
<p>在对表上表锁时，怎么知道表里是否存在行锁呢？于是乎设计InnoDB 的大叔们提出了一种称之为意向锁（英文名： Intention Locks ）：</p>
<ul>
<li>意向共享锁，英文名： Intention Shared Lock ，简称IS锁。当事务准备在某条记录上加S锁时，需要先在<strong>表级别</strong>加一个IS锁。</li>
<li>意向独占锁，英文名： Intention Exclusive Lock ，简称IX锁。当事务准备在某条记录上加X锁时，需要先在<strong>表级别</strong>加一个IX锁。</li>
</ul>
<p>总结一下：<strong>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的</strong></p>
<h3 id="行锁和表锁">行锁和表锁</h3>
<hr>
<p>MySQL 支持多种存储引擎，不同存储引擎对锁的支持也是不一样的</p>
<h4 id="其他存储引擎中的锁">其他存储引擎中的锁</h4>
<p>对于MyISAM 、MEMORY 、MERGE 这些存储引擎来说，它们只支持<strong>表级锁</strong>，而且这些<strong>引擎并不支持事务</strong>，所以使用这些存储引擎的锁一般都是针对当前会话来说的。比方说在Session 1 中对一个表执行SELECT 操作，就相当于为这个表加了一个表级别的S锁，如果在SELECT 操作未完成时， Session 2 中对这个表执行UPDATE 操作，相当于要获取表的X锁，此操作会被阻塞，直到Session 1 中的SELECT 操作完成，释放掉表级别的S锁后，Session 2 中对这个表执行UPDATE 操作才能继续获取X锁，然后执行具体的更新语句。</p>
<h4 id="innodb存储引擎中的锁">InnoDB存储引擎中的锁</h4>
<p>InnoDB 存储引擎既支持表锁，也支持行锁。表锁实现简单，占用资源较少，不过粒度很粗，有时候你仅仅需要锁住几条记录，但使用表锁的话相当于为表中的所有记录都加锁，所以性能比较差。行锁粒度更细，可以实现更精准的并发控制。</p>
<h5 id="innodb中的表级锁">InnoDB中的表级锁</h5>
<ul>
<li>
<p>表级别的S锁、X锁</p>
<p>在对某个表执行一些诸如ALTER TABLE 、DROP TABLE 这类的DDL 语句时，其他事务对这个表并发执行诸如SELECT 、INSERT 、DELETE 、UPDATE 的语句会发生阻塞，同理，某个事务中对某个表执行SELECT 、INSERT 、DELETE 、UPDATE 语句时，在其他会话中对这个表执行DDL 语句也会发生阻塞。这个过程其实是通过在server层使用一种称之为元数据锁（英文名： Metadata Locks ，简称MDL ）东东来实现的，一般情况下也不会使用InnoDB 存储引擎自己提供的表级别的S锁和X锁。</p>
<p>其实这个InnoDB 存储引擎提供的表级S锁或者X锁是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量autocommit=0，innodb_table_locks =1 时，手动获取InnoDB 存储引擎提供的表t 的S锁或者X锁可以这么写：</p>
<pre><code class="language-sql"></code></pre>
</li>
</ul>
<p>LOCK TABLES t READ ： InnoDB 存储引擎会对表t 加表级别的S锁。
LOCK TABLES t WRITE ： InnoDB 存储引擎会对表t 加表级别的X锁。</p>
<pre><code>
+ 表级别的IS锁、IX锁

当我们在对使用InnoDB 存储引擎的表的某些记录加S锁(行锁)之前，那就需要先在表级别加一个IS锁，当我们在对使用InnoDB 存储引擎的表的某些记录加X锁(行锁)之前，那就需要先在表级别加一个IX锁。IS锁和IX锁的使命只是为了后续在加表级别的S锁和X锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录

+ 表级别的AUTO-INC锁

在使用MySQL 过程中，我们可以为表的某个列添加AUTO_INCREMENT 属性，之后在插入记录时，可以不指定该列的值，系统会自动为它赋上递增的值，系统实现这种自动给AUTO_INCREMENT 修饰的列递增赋值的原理主要是两个：

+ 采用AUTO-INC 锁，也就是在执行插入语句时就在表级别加一个AUTO-INC 锁，然后为每条待插入记录的AUTO_INCREMENT 修饰的列分配递增的值，在该语句执行结束后，再把AUTO-INC 锁释放掉。这样一个事务在持有AUTO-INC 锁的过程中，其他事务的插入语句都要被阻塞，可以保证一个语句中分配的递增值是连续的。如果我们的插入语句在执行前不可以确定具体要插入多少条记录（**无法预计即将插入记录的数量**），比方说使用INSERT ... SELECT 、REPLACE ... SELECT 或者LOAD DATA 这种插入语句，一般是使用AUTO-INC 锁为AUTO_INCREMENT 修饰的列生成对应的值。
  
+ 采用一个轻量级的锁，**在为插入语句生成AUTO_INCREMENT 修饰的列的值时获取一下这个轻量级锁**，然后生成本次插入语句需要用到的AUTO_INCREMENT 列的值之后，就**把该轻量级锁释放掉**，并不需要等到整个插入语句执行完才释放锁。如果我们的插入语句在执行前就可以确定具体要插入多少条记录，比方说我们上边举的关于表t 的例子
  中，在语句执行前就可以确定要插入2条记录，那么一般采用轻量级锁的方式对AUTO_INCREMENT 修饰的列进行赋值。这种方式可以避免锁定表，可以提升插入性能。
  
&gt; 设计InnoDB的大叔提供了一个称之为innodb_autoinc_lock_mode的系统变量来控制到底使用上述两种方式中的哪种来为AUTO_INCREMENT修饰的列进行赋值，
  &gt; 
  &gt; 当innodb_autoinc_lock_mode值为0时，一律采用AUTO-INC锁；
  &gt; 
&gt; 当innodb_autoinc_lock_mode值为2时，一律采用轻量级锁；
  &gt; 
  &gt; 当innodb_autoinc_lock_mode值为1时，两种方式混着来（也就是在插入记录数量确定时采用轻量级锁，不确定时使用AUTO-INC锁）。不过当innodb_autoinc_lock_mode值为2时，可能会造成不同事务中的插入语句为AUTO_INCREMENT修饰的列生成的值是交叉的，在有主从复制的场景中是不安全的。



##### InnoDB中的行级锁

行锁，也称为记录锁，顾名思义就是**在记录上加的锁**。不过设计InnoDB 的大叔很有才，一个行锁玩出了各种花样，也就是把行锁分成了各种类型。换句话说即使对同一条记录加行锁，如果类型不同，起到的功效也是不同的

+ Record Locks ：

**单个行记录上的锁** Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表建立的时候没有设置任何一个索引，这时InnoDB存储引擎会使用隐式的主键来进行锁定

+ Gap Locks 间隙锁

我们说MySQL 在REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用MVCC 方案解决，也可以采用加锁方案解决。但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上Record Lock。不过这难不倒设计InnoDB 的
大叔，他们提出了一种称之为Gap Locks 的锁，官方的类型名称为： LOCK_GAP ，我们也可以简称为gap锁。比方说我们把number 值为8 的那条记录加一个gap锁的示意图如下：

![image-20220210152223731](image-20220210152223731.png)

如图中为number 值为8 的记录加了gap锁，意味着不允许别的事务在number 值为8 的记录前边的间隙插入新记录，其实就是number 列的值(3, 8) 这个区间的新记录是不允许立即插入的。比方说有另外一个事务再想插入一条number 值为4 的新记录，它定位到该条新记录的下一条记录的number 值为8，而这条记录上又有一个gap锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后， number 列的值在区间(3, 8) 中的新记录才可以被插入。
这个gap锁的提出**仅仅是为了防止插入幻影记录而提出的**，虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加正经记录锁或者继续加gap锁

+ Next-Key Locks

间隙锁+单行记录锁，有时候我们既想**锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录**，所以设计InnoDB 的大叔们就提出了一种称之为Next-Key Locks 的锁，官方的类型名称为： LOCK_ORDINARY ，我们也可以简称为next-key锁。比方说我们把number 值为8 的那条记录加一个next-key锁的示意图如下：

![image-20220210152631875](image-20220210152631875.png)

+ Insert Intention Locks 

我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的gap锁（ next-key锁也包含gap锁，后边就不强调了），如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。设计InnoDB 的大叔规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。把这种类型的锁命名为Insert Intention Locks ，官方的类型名称为： LOCK_INSERT_INTENTION ，我们也可以称为**插入意向锁**

比方说现在T1 为number 值为8 的记录加了一个gap锁，然后T2 和T3 分别想向hero 表中插入number 值分别为4 、5 的两条记录，所以现在为number 值为8 的记录加的锁的示意图就如下所示：

![image-20220210152955329](image-20220210152955329.png)

从图中可以看到，由于T1 持有gap锁，所以T2 和T3 需要生成一个插入意向锁的锁结构并且处于等待状态。当T1 提交后会把它获取到的锁都释放掉，这样T2 和T3 就能获取到对应的插入意向锁了（本质上就是把插入意向锁对应锁结构的is_waiting 属性改为false ）， T2 和T3 之间也并不会相互阻塞，它们可以同时获取到number 值为8的插入意向锁，然后执行插入操作。事实上**插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁**（ 插入意向锁就是这么鸡肋）。

+ 隐式锁

我们前边说一个事务在执行INSERT 操作时，如果即将插入的间隙已经被其他事务加了gap锁，那么本次INSERT 操作会阻塞，并且当前事务会在该间隙上加一个插入意向锁，否则一般情况下INSERT 操作是不加锁的。那如果一个事务首先插入了一条记录（此时并没有与该记录关联的锁结构），然后另一个事务

+  立即使用SELECT ... LOCK IN SHARE MODE 语句读取这条事务，也就是在要获取这条记录的S锁，或者使用SELECT ... FOR UPDATE 语句读取这条事务或者直接修改这条记录，也就是要获取这条记录的X锁，该咋办？如果允许这种情况的发生，那么可能产生**脏读**问题。
+ 立即修改这条记录，也就是要获取这条记录的X锁，该咋办？
  如果允许这种情况的发生，那么可能产生**脏写**问题。
  这时候我们前边唠叨了很多遍的事务id 又要起作用了。我们把聚簇索引和二级索引中的记录分开看一下：
+ 情景一：对于聚簇索引记录来说，**有一个trx_id 隐藏列，该隐藏列记录着最后改动该记录的事务id** 。
  那么如果在当前事务中新插入一条聚簇索引记录后，该记录的trx_id 隐藏列代表的的就是当前事务的事务id ，**如果其他事务此时想对该记录添加S锁或者X锁时，首先会看一下该记录的trx_id 隐藏列代表的事务是否是当前的活跃事务，如果是的话，那么就帮助当前事务创建一个X锁（也就是为当前事务创建一个锁结构， is_waiting 属性是false ），然后自己进入等待状态（也就是为自己也创建一个锁结构，is_waiting 属性是true ）**。
+  情景二：对于二级索引记录来说，本身并没有trx_id 隐藏列，但是在**二级索引页面的Page Header 部分有一个PAGE_MAX_TRX_ID 属性，该属性代表对该页面做改动的最大的事务id** ，如果**PAGE_MAX_TRX_ID 属性值小于当前最小的活跃事务id ，那么说明对该页面做修改的事务都已经提交了，否则就需要在页面中定位到对应的二级索引记录，然后回表找到它对应的聚簇索引记录**，然后再重复情景一的做法。

**一个事务对新插入的记录可以不显式的加锁**（生成一个锁结构），但是由于事务id 这个牛逼的东东的存在，相当于加了一个**隐式锁**。**别的事务在对这条记录加S锁或者X锁时，由于隐式锁的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态**。



#### InnoDB锁的内存结构

对一条记录加锁的本质就是在内存中创建一个锁结构与之关联，那么是不是一个事务对多条记录加锁，就要创建多个锁结构呢？设计InnoDB 的大叔本着勤俭节约的传统美德，决定在对不同记录加锁时，如果符合下边这些条件：

+ 在同一个事务中进行加锁操作
+ 被加锁的记录在同一个页面中
+ 加锁的类型是一样的
+ 等待状态是一样的

那么这些记录的锁就可以被放到一个锁结构中

![image-20220210161713733](image-20220210161713733.png)

+ 锁所在的事务信息：
不论是表锁还是行锁，都是在**事务执行过程中生成的**，哪个事务生成了这个锁结构，这里就记载着这个事务的信息。
实际上这个所谓的`锁所在的事务信息`在内存结构中只是一个指针而已，所以不会占用多大内存
空间，通过指针可以找到内存中关于该事务的更多信息，比方说事务id是什么。下边介绍的所谓的
`索引信息`其实也是一个指针。

+ 索引信息：
对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。

+ 表锁／行锁信息：

表锁结构和行锁结构在这个位置的内容是不同的：

+ 表锁：
  记载着这是对哪个表加的锁，还有其他的一些信息。
+ 行锁：
  记载了三个重要的信息：
  + Space ID ：记录所在表空间。
  + Page Number ：记录所在页号。
  + n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比
    特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个n_bits 属
    性代表使用了多少比特位。

+ type_mode ：

这是一个32位的数，被分成了lock_mode 、lock_type 和rec_lock_type 三个部分，如图所示：

![image-20220210162112856](image-20220210162112856.png)

1. 锁的模式（ lock_mode ），占用低4位，可选的值如下：
 + LOCK_IS （十进制的0 ）：表示共享意向锁，也就是IS锁。
 + LOCK_IX （十进制的1 ）：表示独占意向锁，也就是IX锁。
 + LOCK_S （十进制的2 ）：表示共享锁，也就是S锁。
 + LOCK_X （十进制的3 ）：表示独占锁，也就是X锁。
 + LOCK_AUTO_INC （十进制的4 ）：表示AUTO-INC锁。

</code></pre>
<p>在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。</p>
<pre><code>
2. 锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用

   + LOCK_TABLE （十进制的16 ），也就是当第5个比特位置为1时，表示表级锁。
   + LOCK_REC （十进制的32 ），也就是当第6个比特位置为1时，表示行级锁。

3. 行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在lock_type 的值为LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：

   + LOCK_ORDINARY （十进制的0 ）：表示next-key锁。
   + LOCK_GAP （十进制的512 ）：也就是当第10个比特位置为1时，表示gap锁。
   + LOCK_REC_NOT_GAP （十进制的1024 ）：也就是当第11个比特位置为1时，表示正经记录锁。
   + LOCK_INSERT_INTENTION （十进制的2048 ）：也就是当第12个比特位置为1时，表示插入意向
     锁。
     怎么还没看见is_waiting 属性呢？这主要还是设计InnoDB 的大叔太抠门了，一个比特位也不想浪
     费，所以他们把is_waiting 属性也放到了type_mode 这个32位的数字中：
   + LOCK_WAIT （十进制的256 ） ：也就是当第9个比特位置为1 时，表示is_waiting 为true ，也
     就是当前事务尚未获取到锁，处在等待状态；当这个比特位为0 时，表示is_waiting 为false ，
     也就是当前事务获取锁成功。

4. 一堆比特位：

   如果是行锁结构的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的n_bits 属性表示
   的。我们前边唠叨InnoDB记录结构的时候说过，页面中的每条记录在记录头信息中都包含一个heap_no 属
   性，伪记录Infimum 的heap_no 值为0 ， Supremum 的heap_no 值为1 ，之后每插入一条记录， heap_no
   值就增1。锁结构最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个heap_no ，不过为
   了编码方便，映射方式有点怪：

</code></pre>

    </div>
    <div class="article-footer">
<blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接: </strong>
      <a href="https://wzgl998877.github.io/2022/01/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/" title="Mysql是怎样运行的" target="_blank" rel="external">https://wzgl998877.github.io/2022/01/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/</a>
    </li>
    <li class="post-copyright-license">
      <strong>License: </strong>
        <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN</a>
    </li>
  </ul>
</blockquote>

<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/wzgl998877/" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://wzgl998877.github.io/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/wzgl998877/" target="_blank"><span class="text-dark">microzheng</span><small class="ml-1x">努力会说谎，但努力不会白费</small></a></h3>
        <div>不想搬砖的码农</div>
      </div>
    </figure>
  </div>
</div>

    </div>
  </article>
</div><nav class="bar bar-footer clearfix" data-stick-bottom>
    <div class="bar-inner">
        <ul class="pager pull-left">
            <li class="prev">
                <a href="https://wzgl998877.github.io/2022/01/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java 并发编程"><i
                        class="icon icon-angle-left"
                        aria-hidden="true"></i><span>&nbsp;&nbsp;下一篇</span></a>
            </li>
            <li class="next">
                <a href="https://wzgl998877.github.io/2022/02/leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"
                    title="LeetCode刷题总结"><span>上一篇&nbsp;&nbsp;</span><i
                        class="icon icon-angle-right" aria-hidden="true"></i></a>
            </li>
            
            <li class="toggle-toc">
                <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false"
                    title="文章目录" role="button">
                    <span>[&nbsp;</span><span>文章目录</span>
                    <i class="text-collapsed icon icon-anchor"></i>
                    <i class="text-in icon icon-close"></i>
                    <span>]</span>
                </a>
            </li>
        </ul>
        <div class="bar-right">
            <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter"
                data-mobile-sites="weibo,qq,qzone"></div>
        </div>
    </div>
</nav>


</main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
<ul class="social-links">
    <li><a href="https://github.com/wzgl998877/" target="_blank" title="github" data-toggle=tooltip data-placement=top >
            <i class="icon icon-github"></i></a></li>
    <li><a href="https://wzgl998877.github.io/index.xml" target="_blank" title="rss" data-toggle=tooltip data-placement=top >
            <i class="icon icon-rss"></i></a></li>
</ul>
  <div class="copyright">
    &copy;2022  -
    2024
    <div class="publishby">
        Theme by <a href="https://github.com/wzgl998877/" target="_blank"> microzheng </a>base on<a href="https://github.com/xiaoheiAh/hugo-theme-pure" target="_blank"> pure</a>.
    </div>
    
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            showMathMenu: false, //disables context menu
            tex2jax: {
            inlineMath: [ ['$','$'], ['\\(','\\)'] ]
           }
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script>
    window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/highlight.min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/python.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/javascript.min.js" defer></script>
<script type="text/javascript" src="https://cdn.staticfile.org/highlight.js/9.15.10/languages/java.min.js" defer></script><script>
    hljs.configure({
        tabReplace: '    ', 
        classPrefix: ''     
        
    })
    hljs.initHighlightingOnLoad();
</script>
<script src="https://wzgl998877.github.io/js/application.min.a94ab19cb63a95c8d7fbd7b85cab3ddeea8c369bdf75b9cab6708787ead123af.js"></script>
<script src="https://wzgl998877.github.io/js/plugin.min.19c5bcb2fb0789ab4f2b7834e5ceb5e92635645605bab902c1024b25f1502364.js"></script>

<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(未命名)',
            },
            ROOT_URL: 'https:\/\/wzgl998877.github.io\/',
            CONTENT_URL: 'https:\/\/wzgl998877.github.io\/\/searchindex.json ',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script type="text/javascript" src="https://wzgl998877.github.io/js/insight.min.4a2d52de4bfff73e0c688404fe3d17c9a3ae12d9888e1e1ac9c690e4890de2ded50fe55f2b819c2ba55435a76f396f3ea6805765f0b0af5635cdf74ea459eab0.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    tocbot.init({
        
        tocSelector: '.js-toc',
        
        contentSelector: '.js-toc-content',
        
        headingSelector: 'h1, h2, h3',
        
        hasInnerContainers: true,
    });
</script>


  </body>
</html>
